<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Ervin Remus Radosavlevici (ervin210@icloud.com)">
    <meta name="copyright" content="© 2025 Ervin Remus Radosavlevici (ervin210@icloud.com) - Toate drepturile rezervate">
    <meta name="description" content="Noțiuni de Bază în Computația Cuantică - Quantum Computing Academy">
    <title>Noțiuni de Bază - Quantum Computing Academy</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/main.css') }}">
</head>
<body>
    <header>
        <nav class="main-nav">
            <div class="logo">
                <h1>Quantum Computing Academy</h1>
                <span class="copyright-tag">© 2025 Ervin Remus Radosavlevici</span>
            </div>
            <ul class="nav-links">
                <li><a href="{{ url_for('index') }}">Acasă</a></li>
                <li><a href="{{ url_for('quantum_basics') }}" class="active">Noțiuni de Bază</a></li>
                <li><a href="{{ url_for('quantum_algorithms') }}">Algoritmi Cuantici</a></li>
                <li><a href="{{ url_for('quantum_ml') }}">Cuantic & ML</a></li>
                <li><a href="{{ url_for('dna_security_page') }}">Securitate ADN</a></li>
                <li><a href="{{ url_for('resources') }}">Resurse</a></li>
                <li><a href="{{ url_for('login_page') }}" class="btn-login">Autentificare</a></li>
            </ul>
        </nav>
    </header>

    <main>
        <section class="page-header">
            <h2>Noțiuni de Bază în Computația Cuantică</h2>
            <p>Explorați principiile fundamentale ale computației cuantice și interacționați cu simulări interactive.</p>
            <div class="security-badge">
                <span class="security-key">Cheie de securitate: {{ security_key }}</span>
                <span class="security-info">Protejat prin tehnologie cuantică și ADN</span>
            </div>
        </section>

        <section class="quantum-principles">
            <h3>Principii Fundamentale</h3>
            <div class="principles-grid">
                <div class="principle-card">
                    <h4>Superpoziția</h4>
                    <p>Spre deosebire de biții clasici care pot fi doar 0 sau 1, qubiții pot exista într-o superpoziție a ambelor stări simultan. Acest fenomen permite computerelor cuantice să proceseze exponențial mai multă informație decât computerele clasice.</p>
                    <div class="principle-interactive" id="superposition-interactive">
                        <div class="qubit-display">
                            <div class="qubit-sphere" id="superposition-sphere">
                                <div class="qubit-state-marker"></div>
                            </div>
                            <div class="qubit-controls">
                                <p>Controlează superpoziția:</p>
                                <input type="range" id="superposition-slider" min="0" max="100" value="50">
                                <div class="slider-labels">
                                    <span>|0⟩</span>
                                    <span>Superpoziție</span>
                                    <span>|1⟩</span>
                                </div>
                            </div>
                        </div>
                        <div class="state-display">
                            <p>Stare cuantică:</p>
                            <div class="quantum-state" id="superposition-state">
                                <span class="ket-notation">|ψ⟩ = </span>
                                <span class="state-formula">
                                    <span id="alpha-value">0.7071</span>|0⟩ + <span id="beta-value">0.7071</span>|1⟩
                                </span>
                            </div>
                            <div class="state-probabilities">
                                <div class="probability">
                                    <span>Prob(|0⟩):</span>
                                    <span id="prob-zero">50%</span>
                                </div>
                                <div class="probability">
                                    <span>Prob(|1⟩):</span>
                                    <span id="prob-one">50%</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="principle-card">
                    <h4>Interferența</h4>
                    <p>Amplitudinile de probabilitate ale qubiților pot interfera constructiv sau destructiv, permițând algoritmilor cuantici să scoată în evidență rezultatele corecte și să anuleze cele incorecte.</p>
                    <div class="principle-interactive" id="interference-interactive">
                        <div class="wave-container">
                            <div class="quantum-wave" id="wave1">
                                <div class="wave-label">Unda 1</div>
                            </div>
                            <div class="quantum-wave" id="wave2">
                                <div class="wave-label">Unda 2</div>
                            </div>
                            <div class="quantum-wave result" id="result-wave">
                                <div class="wave-label">Rezultat</div>
                            </div>
                        </div>
                        <div class="wave-controls">
                            <div class="wave-control">
                                <label for="phase-slider">Diferență de fază:</label>
                                <input type="range" id="phase-slider" min="0" max="360" value="0">
                                <span id="phase-value">0°</span>
                            </div>
                            <div class="interference-info">
                                <div id="interference-type">Interferență constructivă</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="principle-card">
                    <h4>Înlănțuirea Cuantică</h4>
                    <p>Când qubiții sunt înlănțuiți, starea fiecărui qubit nu poate fi descrisă independent de starea celorlalți. Această proprietate permite transmiterea instantanee a informației cuantice între qubiți, chiar dacă aceștia sunt separați fizic.</p>
                    <div class="principle-interactive" id="entanglement-interactive">
                        <div class="entangled-qubits">
                            <div class="entangled-qubit" id="qubit-a">
                                <div class="qubit-label">Qubit A</div>
                                <div class="qubit-circle">?</div>
                                <div class="measurement-result" id="result-a"></div>
                            </div>
                            <div class="entanglement-line">
                                <svg width="100%" height="100%" viewBox="0 0 100 20">
                                    <line x1="0" y1="10" x2="100" y2="10" stroke="#0066cc" stroke-width="2" stroke-dasharray="5,5" />
                                </svg>
                            </div>
                            <div class="entangled-qubit" id="qubit-b">
                                <div class="qubit-label">Qubit B</div>
                                <div class="qubit-circle">?</div>
                                <div class="measurement-result" id="result-b"></div>
                            </div>
                        </div>
                        <div class="entanglement-controls">
                            <button id="create-bell-pair" class="quantum-button">Creează pereche Bell</button>
                            <button id="measure-qubit-a" class="quantum-button" disabled>Măsoară Qubit A</button>
                            <button id="reset-entanglement" class="quantum-button secondary" disabled>Resetează</button>
                        </div>
                        <div class="entanglement-explanation">
                            <p id="entanglement-status">Creați o pereche Bell pentru a demonstra înlănțuirea cuantică.</p>
                        </div>
                    </div>
                </div>
                
                <div class="principle-card">
                    <h4>Porțile Cuantice</h4>
                    <p>Porțile cuantice sunt operațiile de bază ale calculului cuantic, transformând stările qubiților. Spre deosebire de porțile clasice, toate porțile cuantice sunt reversibile, cu excepția măsurătorii.</p>
                    <div class="principle-interactive" id="gates-interactive">
                        <div class="bloch-sphere-container">
                            <div id="bloch-sphere-display">
                                <img id="bloch-sphere-image" src="{{ url_for('api_bloch_sphere', theta=0, phi=0) }}" alt="Bloch Sphere">
                            </div>
                            <div class="state-notation">
                                <span>|ψ⟩ = </span>
                                <span id="gate-state-formula">|0⟩</span>
                            </div>
                        </div>
                        <div class="gates-controls">
                            <div class="gates-selection">
                                <button data-gate="X" class="gate-button">X</button>
                                <button data-gate="H" class="gate-button">H</button>
                                <button data-gate="Z" class="gate-button">Z</button>
                                <button data-gate="Y" class="gate-button">Y</button>
                                <button data-gate="S" class="gate-button">S</button>
                                <button data-gate="T" class="gate-button">T</button>
                            </div>
                            <div class="gates-info">
                                <div id="current-gate">Selectați o poartă</div>
                                <div id="gate-description"></div>
                            </div>
                            <button id="reset-qubit" class="quantum-button secondary">Resetează la |0⟩</button>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="quantum-applications">
            <h3>Aplicațiile Computației Cuantice</h3>
            <div class="applications-grid">
                <div class="application-card">
                    <div class="application-icon cryptography-icon"></div>
                    <h4>Criptografie Cuantică</h4>
                    <p>Utilizează proprietățile mecanicii cuantice pentru a crea protocoale de criptare inviolabile, precum distribuția cheilor cuantice (QKD) care poate detecta orice încercare de interceptare.</p>
                </div>
                <div class="application-card">
                    <div class="application-icon chemistry-icon"></div>
                    <h4>Simulări Chimice</h4>
                    <p>Simulează comportamentul moleculelor și reacțiilor chimice cu precizie extraordinară, accelerând descoperirea de noi medicamente, materiale și catalizatori.</p>
                </div>
                <div class="application-card">
                    <div class="application-icon optimization-icon"></div>
                    <h4>Optimizare</h4>
                    <p>Rezolvă probleme complexe de optimizare în logistică, finanțe și inginerie, găsind soluții optime mult mai rapid decât computerele clasice.</p>
                </div>
                <div class="application-card">
                    <div class="application-icon ai-icon"></div>
                    <h4>Inteligență Artificială</h4>
                    <p>Îmbunătățește algoritmi de machine learning și recunoaștere de tipare prin utilizarea stărilor cuantice pentru a procesa exponențial mai multe date simultan.</p>
                </div>
            </div>
        </section>

        <section class="quantum-circuit-builder">
            <h3>Constructor de Circuite Cuantice</h3>
            <p>Construiți și simulați circuite cuantice simple pentru a înțelege principiile de bază.</p>
            
            <div class="circuit-builder-container">
                <div class="circuit-design">
                    <div class="qubits-selection">
                        <label for="qubit-count">Număr de qubiți:</label>
                        <select id="qubit-count">
                            <option value="1">1 qubit</option>
                            <option value="2" selected>2 qubiți</option>
                            <option value="3">3 qubiți</option>
                        </select>
                    </div>
                    
                    <div class="circuit-grid" id="circuit-grid">
                        <div class="circuit-labels">
                            <div class="qubit-label">q₀</div>
                            <div class="qubit-label">q₁</div>
                        </div>
                        <div class="circuit-wires">
                            <div class="circuit-wire"></div>
                            <div class="circuit-wire"></div>
                        </div>
                        <div class="gate-slots">
                            <div class="gate-slot" data-qubit="0" data-position="0"></div>
                            <div class="gate-slot" data-qubit="0" data-position="1"></div>
                            <div class="gate-slot" data-qubit="0" data-position="2"></div>
                            <div class="gate-slot" data-qubit="0" data-position="3"></div>
                            <div class="gate-slot" data-qubit="1" data-position="0"></div>
                            <div class="gate-slot" data-qubit="1" data-position="1"></div>
                            <div class="gate-slot" data-qubit="1" data-position="2"></div>
                            <div class="gate-slot" data-qubit="1" data-position="3"></div>
                        </div>
                        <div class="measurement-slots">
                            <div class="measurement-slot" data-qubit="0"></div>
                            <div class="measurement-slot" data-qubit="1"></div>
                        </div>
                    </div>
                    
                    <div class="gate-palette">
                        <div class="gate-category">
                            <h4>Porți de bază</h4>
                            <div class="gates">
                                <div class="draggable-gate" data-gate="H" draggable="true">H</div>
                                <div class="draggable-gate" data-gate="X" draggable="true">X</div>
                                <div class="draggable-gate" data-gate="Y" draggable="true">Y</div>
                                <div class="draggable-gate" data-gate="Z" draggable="true">Z</div>
                            </div>
                        </div>
                        <div class="gate-category">
                            <h4>Porți de fază</h4>
                            <div class="gates">
                                <div class="draggable-gate" data-gate="S" draggable="true">S</div>
                                <div class="draggable-gate" data-gate="T" draggable="true">T</div>
                            </div>
                        </div>
                        <div class="gate-category">
                            <h4>Porți cu doi qubiți</h4>
                            <div class="gates">
                                <div class="draggable-gate multi-qubit" data-gate="CNOT" draggable="true">CNOT</div>
                                <div class="draggable-gate multi-qubit" data-gate="SWAP" draggable="true">SWAP</div>
                            </div>
                        </div>
                        <div class="gate-category">
                            <h4>Măsurătoare</h4>
                            <div class="gates">
                                <div class="draggable-gate" data-gate="MEASURE" draggable="true">
                                    <svg width="24" height="24" viewBox="0 0 24 24">
                                        <path d="M5,3L5,13L9,13L9,7L13,7L13,10L17,10L17,3L5,3Z" fill="#0066cc"/>
                                        <path d="M11,15L11,18L8,18L12,22L16,18L13,18L13,15L11,15Z" fill="#0066cc"/>
                                    </svg>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="circuit-actions">
                        <button id="clear-circuit" class="quantum-button secondary">Șterge circuitul</button>
                        <button id="run-circuit" class="quantum-button">Rulează simularea</button>
                    </div>
                </div>
                
                <div class="simulation-results">
                    <h4>Rezultate simulare</h4>
                    <div class="results-container">
                        <div class="circuit-visualization">
                            <h5>Vizualizare circuit</h5>
                            <div id="circuit-visualization">
                                <p class="placeholder-text">Circuitul va fi afișat aici după rulare...</p>
                            </div>
                        </div>
                        <div class="measurement-results">
                            <h5>Rezultate măsurători</h5>
                            <div id="measurement-visualization">
                                <p class="placeholder-text">Rezultatele măsurătorilor vor fi afișate aici...</p>
                            </div>
                        </div>
                        <div class="state-vector">
                            <h5>Vector de stare</h5>
                            <div id="statevector-visualization">
                                <p class="placeholder-text">Vectorul de stare va fi afișat aici...</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        
        <section class="quantum-resources">
            <h3>Resurse pentru Începători</h3>
            <div class="resources-list">
                <div class="resource-item">
                    <div class="resource-icon book-icon"></div>
                    <div class="resource-content">
                        <h4>Cărți și Articole</h4>
                        <ul>
                            <li><a href="#">Introducere în Computația Cuantică pentru Programatori</a></li>
                            <li><a href="#">Principiile Mecanicii Cuantice Explicate</a></li>
                            <li><a href="#">De la Bit la Qubit: Noțiuni de Bază</a></li>
                        </ul>
                    </div>
                </div>
                <div class="resource-item">
                    <div class="resource-icon video-icon"></div>
                    <div class="resource-content">
                        <h4>Tutoriale Video</h4>
                        <ul>
                            <li><a href="#">Seria de tutoriale "Quantum Computing Explained"</a></li>
                            <li><a href="#">Qiskit Demos: Demonstrații interactive</a></li>
                            <li><a href="#">Porți Cuantice: De la Teorie la Implementare</a></li>
                        </ul>
                    </div>
                </div>
                <div class="resource-item">
                    <div class="resource-icon course-icon"></div>
                    <div class="resource-content">
                        <h4>Cursuri Online</h4>
                        <ul>
                            <li><a href="#">Fundamente de Computație Cuantică (Universitatea Tehnică)</a></li>
                            <li><a href="#">Algoritmi Cuantici pentru Începători</a></li>
                            <li><a href="#">Implementarea Circuitelor Cuantice cu Qiskit</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <div class="footer-content">
            <div class="footer-copyright">
                <p>© 2025 Ervin Remus Radosavlevici (ervin210@icloud.com)</p>
                <p>Toate drepturile rezervate global. Protejat de legile internaționale ale drepturilor de autor.</p>
            </div>
            <div class="footer-security">
                <p>Securizat cu tehnologie cuantică și ADN</p>
                <p>Cheie de Securitate: {{ security_key }}</p>
            </div>
            <div class="footer-links">
                <ul>
                    <li><a href="{{ url_for('quantum_basics') }}">Noțiuni de Bază</a></li>
                    <li><a href="{{ url_for('quantum_algorithms') }}">Algoritmi Cuantici</a></li>
                    <li><a href="{{ url_for('dna_security_page') }}">Securitate ADN</a></li>
                    <li><a href="{{ url_for('resources') }}">Resurse</a></li>
                </ul>
            </div>
        </div>
    </footer>

    <script src="{{ url_for('static', filename='js/security.js') }}"></script>
    <script src="{{ url_for('static', filename='js/breach-detector.js') }}"></script>
    <script src="{{ url_for('static', filename='js/quantum_visuals.js') }}"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize interactive elements
            initializeSuperpositionDemo();
            initializeInterferenceDemo();
            initializeEntanglementDemo();
            initializeGatesDemo();
            initializeCircuitBuilder();
            
            // Superposition Demo
            function initializeSuperpositionDemo() {
                const slider = document.getElementById('superposition-slider');
                const alphaValue = document.getElementById('alpha-value');
                const betaValue = document.getElementById('beta-value');
                const probZero = document.getElementById('prob-zero');
                const probOne = document.getElementById('prob-one');
                const marker = document.querySelector('#superposition-sphere .qubit-state-marker');
                
                slider.addEventListener('input', function() {
                    // Calculate probabilities based on slider
                    const sliderValue = this.value / 100;
                    const theta = sliderValue * Math.PI;
                    
                    // Update alpha and beta values
                    const alpha = Math.cos(theta / 2);
                    const beta = Math.sin(theta / 2);
                    
                    alphaValue.textContent = alpha.toFixed(4);
                    betaValue.textContent = beta.toFixed(4);
                    
                    // Update probabilities
                    const prob0 = (alpha * alpha) * 100;
                    const prob1 = (beta * beta) * 100;
                    
                    probZero.textContent = prob0.toFixed(0) + '%';
                    probOne.textContent = prob1.toFixed(0) + '%';
                    
                    // Update marker position
                    const angle = (sliderValue * 180) - 90;
                    marker.style.transform = `rotate(${angle}deg) translateX(40px)`;
                });
            }
            
            // Interference Demo
            function initializeInterferenceDemo() {
                const phaseSlider = document.getElementById('phase-slider');
                const phaseValue = document.getElementById('phase-value');
                const interferenceType = document.getElementById('interference-type');
                const wave1 = document.getElementById('wave1');
                const wave2 = document.getElementById('wave2');
                const resultWave = document.getElementById('result-wave');
                
                // Create wave paths
                createWave(wave1, 0);
                createWave(wave2, 0);
                createResultWave(0);
                
                phaseSlider.addEventListener('input', function() {
                    const phaseAngle = this.value;
                    phaseValue.textContent = phaseAngle + '°';
                    
                    // Update wave2 with phase difference
                    createWave(wave2, phaseAngle);
                    
                    // Update result wave
                    createResultWave(phaseAngle);
                    
                    // Update interference type text
                    if (phaseAngle < 45 || phaseAngle > 315) {
                        interferenceType.textContent = 'Interferență constructivă';
                        interferenceType.style.color = '#4CAF50';
                    } else if (phaseAngle > 135 && phaseAngle < 225) {
                        interferenceType.textContent = 'Interferență destructivă';
                        interferenceType.style.color = '#f44336';
                    } else {
                        interferenceType.textContent = 'Interferență parțială';
                        interferenceType.style.color = '#FF9800';
                    }
                });
                
                function createWave(element, phase) {
                    const width = 300;
                    const height = 60;
                    const amplitude = 25;
                    const frequency = 2;
                    
                    const phaseRad = (phase * Math.PI) / 180;
                    
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('width', width);
                    svg.setAttribute('height', height);
                    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
                    
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    let d = `M 0 ${height/2}`;
                    
                    for (let x = 0; x <= width; x += 2) {
                        const y = height/2 + amplitude * Math.sin((x * frequency * Math.PI / 180) + phaseRad);
                        d += ` L ${x} ${y}`;
                    }
                    
                    path.setAttribute('d', d);
                    path.setAttribute('stroke', '#0066cc');
                    path.setAttribute('stroke-width', '2');
                    path.setAttribute('fill', 'none');
                    
                    // Clear previous SVG
                    element.innerHTML = '';
                    element.appendChild(svg);
                    svg.appendChild(path);
                }
                
                function createResultWave(phase) {
                    const width = 300;
                    const height = 60;
                    const amplitude = 25;
                    const frequency = 2;
                    
                    const phaseRad = (phase * Math.PI) / 180;
                    
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('width', width);
                    svg.setAttribute('height', height);
                    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
                    
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    let d = `M 0 ${height/2}`;
                    
                    for (let x = 0; x <= width; x += 2) {
                        // Adding original wave and phase-shifted wave
                        const y1 = amplitude * Math.sin(x * frequency * Math.PI / 180);
                        const y2 = amplitude * Math.sin((x * frequency * Math.PI / 180) + phaseRad);
                        const y = height/2 + (y1 + y2);
                        d += ` L ${x} ${y}`;
                    }
                    
                    path.setAttribute('d', d);
                    path.setAttribute('stroke', '#4CAF50');
                    path.setAttribute('stroke-width', '2');
                    path.setAttribute('fill', 'none');
                    
                    // Clear previous SVG
                    resultWave.innerHTML = '';
                    resultWave.appendChild(svg);
                    svg.appendChild(path);
                }
            }
            
            // Entanglement Demo
            function initializeEntanglementDemo() {
                const createBellPairBtn = document.getElementById('create-bell-pair');
                const measureQubitABtn = document.getElementById('measure-qubit-a');
                const resetEntanglementBtn = document.getElementById('reset-entanglement');
                const qubitA = document.getElementById('qubit-a');
                const qubitB = document.getElementById('qubit-b');
                const resultA = document.getElementById('result-a');
                const resultB = document.getElementById('result-b');
                const entanglementStatus = document.getElementById('entanglement-status');
                
                let entangled = false;
                let qubitAMeasured = false;
                
                createBellPairBtn.addEventListener('click', function() {
                    // Create Bell pair
                    entangled = true;
                    qubitAMeasured = false;
                    
                    // Update UI
                    qubitA.querySelector('.qubit-circle').textContent = '⟨?|';
                    qubitB.querySelector('.qubit-circle').textContent = '|?⟩';
                    qubitA.querySelector('.qubit-circle').classList.add('entangled');
                    qubitB.querySelector('.qubit-circle').classList.add('entangled');
                    
                    resultA.textContent = '';
                    resultB.textContent = '';
                    
                    entanglementStatus.innerHTML = 'Pereche Bell creată! Qubiții sunt acum <strong>înlănțuiți cuantic</strong>. Măsoară unul dintre qubiți pentru a observa efectul înlănțuirii.';
                    
                    // Enable/disable buttons
                    createBellPairBtn.disabled = true;
                    measureQubitABtn.disabled = false;
                    resetEntanglementBtn.disabled = false;
                });
                
                measureQubitABtn.addEventListener('click', function() {
                    if (!entangled) return;
                    
                    // Measure qubit A
                    qubitAMeasured = true;
                    const measurement = Math.random() > 0.5 ? '1' : '0';
                    
                    // Update UI
                    qubitA.querySelector('.qubit-circle').textContent = measurement;
                    resultA.textContent = `Măsurat: |${measurement}⟩`;
                    qubitA.querySelector('.qubit-circle').classList.remove('entangled');
                    qubitA.querySelector('.qubit-circle').classList.add('measured');
                    
                    // Update qubit B (entanglement causes instantaneous effect)
                    setTimeout(() => {
                        qubitB.querySelector('.qubit-circle').textContent = measurement;
                        resultB.textContent = `Nedeterminat → |${measurement}⟩`;
                        qubitB.querySelector('.qubit-circle').classList.remove('entangled');
                        qubitB.querySelector('.qubit-circle').classList.add('measured');
                        
                        entanglementStatus.innerHTML = `<strong>Înlănțuire demonstrată!</strong> La măsurarea qubitului A cu rezultatul |${measurement}⟩, qubitului B își colapsează instantaneu starea la |${measurement}⟩ din cauza înlănțuirii cuantice, indiferent de distanța dintre qubiți.`;
                    }, 1000);
                    
                    // Disable measure button
                    measureQubitABtn.disabled = true;
                });
                
                resetEntanglementBtn.addEventListener('click', function() {
                    // Reset state
                    entangled = false;
                    qubitAMeasured = false;
                    
                    // Reset UI
                    qubitA.querySelector('.qubit-circle').textContent = '?';
                    qubitB.querySelector('.qubit-circle').textContent = '?';
                    qubitA.querySelector('.qubit-circle').classList.remove('entangled', 'measured');
                    qubitB.querySelector('.qubit-circle').classList.remove('entangled', 'measured');
                    
                    resultA.textContent = '';
                    resultB.textContent = '';
                    
                    entanglementStatus.textContent = 'Creați o pereche Bell pentru a demonstra înlănțuirea cuantică.';
                    
                    // Reset buttons
                    createBellPairBtn.disabled = false;
                    measureQubitABtn.disabled = true;
                    resetEntanglementBtn.disabled = true;
                });
            }
            
            // Gates Demo
            function initializeGatesDemo() {
                const blochSphereImage = document.getElementById('bloch-sphere-image');
                const gateStateFormula = document.getElementById('gate-state-formula');
                const gateButtons = document.querySelectorAll('.gate-button');
                const resetQubitBtn = document.getElementById('reset-qubit');
                const currentGate = document.getElementById('current-gate');
                const gateDescription = document.getElementById('gate-description');
                
                // Gate descriptions
                const gateDescriptions = {
                    'X': 'Poarta X (NOT) inversează stările |0⟩ și |1⟩.',
                    'H': 'Poarta Hadamard creează superpoziție, transformând |0⟩ în (|0⟩+|1⟩)/√2.',
                    'Z': 'Poarta Z schimbă faza pentru |1⟩, lăsând |0⟩ neschimbat.',
                    'Y': 'Poarta Y combină inversarea și schimbarea fazei.',
                    'S': 'Poarta S aplică o rotație de fază de 90°.',
                    'T': 'Poarta T aplică o rotație de fază de 45°.'
                };
                
                // Current qubit state parameters
                let theta = 0;
                let phi = 0;
                let currentStateText = '|0⟩';
                
                // Initialize Bloch sphere
                updateBlochSphere();
                
                // Gate button event listeners
                gateButtons.forEach(button => {
                    button.addEventListener('click', function() {
                        const gate = this.dataset.gate;
                        applyGate(gate);
                        currentGate.textContent = `Poarta ${gate} aplicată`;
                        gateDescription.textContent = gateDescriptions[gate] || '';
                    });
                });
                
                // Reset button
                resetQubitBtn.addEventListener('click', function() {
                    theta = 0;
                    phi = 0;
                    currentStateText = '|0⟩';
                    updateBlochSphere();
                    currentGate.textContent = 'Qubit resetat la |0⟩';
                    gateDescription.textContent = '';
                });
                
                function applyGate(gate) {
                    switch(gate) {
                        case 'X':
                            theta = Math.PI - theta;
                            phi = phi + Math.PI;
                            currentStateText = (currentStateText === '|0⟩') ? '|1⟩' : '|0⟩';
                            break;
                        case 'H':
                            if (theta === 0) {
                                theta = Math.PI / 2;
                                phi = 0;
                                currentStateText = '(|0⟩+|1⟩)/√2';
                            } else if (theta === Math.PI) {
                                theta = Math.PI / 2;
                                phi = Math.PI;
                                currentStateText = '(|0⟩-|1⟩)/√2';
                            } else if (Math.abs(theta - Math.PI/2) < 0.01 && Math.abs(phi) < 0.01) {
                                theta = 0;
                                phi = 0;
                                currentStateText = '|0⟩';
                            } else if (Math.abs(theta - Math.PI/2) < 0.01 && Math.abs(phi - Math.PI) < 0.01) {
                                theta = Math.PI;
                                phi = 0;
                                currentStateText = '|1⟩';
                            } else {
                                // For other states, approximate
                                theta = Math.PI - theta;
                                currentStateText = 'Stare mixtă';
                            }
                            break;
                        case 'Z':
                            if (Math.abs(theta - Math.PI) < 0.01) {
                                currentStateText = '-|1⟩';
                            } else if (Math.abs(theta - Math.PI/2) < 0.01) {
                                if (Math.abs(phi) < 0.01) {
                                    currentStateText = '(|0⟩-|1⟩)/√2';
                                } else if (Math.abs(phi - Math.PI) < 0.01) {
                                    currentStateText = '(|0⟩+|1⟩)/√2';
                                } else {
                                    currentStateText = 'Stare mixtă';
                                }
                                phi = (phi + Math.PI) % (2 * Math.PI);
                            }
                            break;
                        case 'Y':
                            theta = Math.PI - theta;
                            phi = (phi + Math.PI/2) % (2 * Math.PI);
                            if (currentStateText === '|0⟩') {
                                currentStateText = 'i|1⟩';
                            } else if (currentStateText === '|1⟩') {
                                currentStateText = '-i|0⟩';
                            } else {
                                currentStateText = 'Stare mixtă';
                            }
                            break;
                        case 'S':
                            if (currentStateText === '|1⟩') {
                                currentStateText = 'i|1⟩';
                            } else if (Math.abs(theta - Math.PI/2) < 0.01) {
                                phi = (phi + Math.PI/2) % (2 * Math.PI);
                                currentStateText = 'Stare mixtă';
                            }
                            break;
                        case 'T':
                            if (currentStateText === '|1⟩') {
                                currentStateText = 'e^(iπ/4)|1⟩';
                            } else if (Math.abs(theta - Math.PI/2) < 0.01) {
                                phi = (phi + Math.PI/4) % (2 * Math.PI);
                                currentStateText = 'Stare mixtă';
                            }
                            break;
                    }
                    
                    updateBlochSphere();
                }
                
                function updateBlochSphere() {
                    // Update Bloch sphere image via API call
                    blochSphereImage.src = `/api/bloch_sphere?theta=${theta}&phi=${phi}`;
                    gateStateFormula.textContent = currentStateText;
                }
            }
            
            // Circuit Builder
            function initializeCircuitBuilder() {
                const qubitCountSelect = document.getElementById('qubit-count');
                const circuitGrid = document.getElementById('circuit-grid');
                const clearCircuitBtn = document.getElementById('clear-circuit');
                const runCircuitBtn = document.getElementById('run-circuit');
                const circuitLabels = circuitGrid.querySelector('.circuit-labels');
                const circuitWires = circuitGrid.querySelector('.circuit-wires');
                const gateSlots = circuitGrid.querySelector('.gate-slots');
                const measurementSlots = circuitGrid.querySelector('.measurement-slots');
                const draggableGates = document.querySelectorAll('.draggable-gate');
                
                let circuit = [];
                let measurements = [];
                
                // Initialize with 2 qubits
                updateQubitCount(2);
                
                // Qubit count change event
                qubitCountSelect.addEventListener('change', function() {
                    const count = parseInt(this.value);
                    updateQubitCount(count);
                    clearCircuit();
                });
                
                // Initialize drag and drop
                draggableGates.forEach(gate => {
                    gate.addEventListener('dragstart', function(e) {
                        e.dataTransfer.setData('text/plain', this.dataset.gate);
                    });
                });
                
                // Clear circuit button
                clearCircuitBtn.addEventListener('click', clearCircuit);
                
                // Run circuit button
                runCircuitBtn.addEventListener('click', runCircuit);
                
                function updateQubitCount(count) {
                    // Clear previous elements
                    circuitLabels.innerHTML = '';
                    circuitWires.innerHTML = '';
                    gateSlots.innerHTML = '';
                    measurementSlots.innerHTML = '';
                    
                    // Add new elements based on qubit count
                    for (let i = 0; i < count; i++) {
                        // Add qubit label
                        const label = document.createElement('div');
                        label.className = 'qubit-label';
                        label.textContent = `q₀${i}`;
                        circuitLabels.appendChild(label);
                        
                        // Add wire
                        const wire = document.createElement('div');
                        wire.className = 'circuit-wire';
                        circuitWires.appendChild(wire);
                        
                        // Add gate slots (4 slots per qubit)
                        for (let j = 0; j < 4; j++) {
                            const slot = document.createElement('div');
                            slot.className = 'gate-slot';
                            slot.dataset.qubit = i;
                            slot.dataset.position = j;
                            gateSlots.appendChild(slot);
                            
                            // Add drop event listeners
                            slot.addEventListener('dragover', function(e) {
                                e.preventDefault();
                                this.classList.add('dragover');
                            });
                            
                            slot.addEventListener('dragleave', function() {
                                this.classList.remove('dragover');
                            });
                            
                            slot.addEventListener('drop', function(e) {
                                e.preventDefault();
                                this.classList.remove('dragover');
                                
                                const gate = e.dataTransfer.getData('text/plain');
                                const qubit = parseInt(this.dataset.qubit);
                                const position = parseInt(this.dataset.position);
                                
                                addGateToCircuit(gate, qubit, position);
                            });
                        }
                        
                        // Add measurement slot
                        const measureSlot = document.createElement('div');
                        measureSlot.className = 'measurement-slot';
                        measureSlot.dataset.qubit = i;
                        measurementSlots.appendChild(measureSlot);
                        
                        // Add drop event for measurement
                        measureSlot.addEventListener('dragover', function(e) {
                            e.preventDefault();
                            this.classList.add('dragover');
                        });
                        
                        measureSlot.addEventListener('dragleave', function() {
                            this.classList.remove('dragover');
                        });
                        
                        measureSlot.addEventListener('drop', function(e) {
                            e.preventDefault();
                            this.classList.remove('dragover');
                            
                            const gate = e.dataTransfer.getData('text/plain');
                            const qubit = parseInt(this.dataset.qubit);
                            
                            if (gate === 'MEASURE') {
                                addMeasurement(qubit);
                            }
                        });
                    }
                }
                
                function addGateToCircuit(gate, qubit, position) {
                    // Find the gate slot
                    const slot = document.querySelector(`.gate-slot[data-qubit="${qubit}"][data-position="${position}"]`);
                    
                    // Remove any existing gate
                    while (slot.firstChild) {
                        slot.removeChild(slot.firstChild);
                    }
                    
                    // Create gate element
                    const gateElement = document.createElement('div');
                    gateElement.className = 'circuit-gate';
                    gateElement.textContent = gate;
                    gateElement.dataset.gate = gate;
                    
                    // Add to slot
                    slot.appendChild(gateElement);
                    
                    // Update circuit data
                    circuit.push({
                        gate: gate,
                        qubit: qubit,
                        position: position
                    });
                    
                    // Add click handler to remove gate
                    gateElement.addEventListener('click', function() {
                        slot.removeChild(gateElement);
                        // Remove from circuit data
                        const index = circuit.findIndex(g => 
                            g.gate === gate && g.qubit === qubit && g.position === position
                        );
                        if (index !== -1) {
                            circuit.splice(index, 1);
                        }
                    });
                }
                
                function addMeasurement(qubit) {
                    // Find the measurement slot
                    const slot = document.querySelector(`.measurement-slot[data-qubit="${qubit}"]`);
                    
                    // Remove any existing measurement
                    while (slot.firstChild) {
                        slot.removeChild(slot.firstChild);
                    }
                    
                    // Create measurement element
                    const measureElement = document.createElement('div');
                    measureElement.className = 'measurement-gate';
                    
                    // Create SVG icon
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('width', '24');
                    svg.setAttribute('height', '24');
                    svg.setAttribute('viewBox', '0 0 24 24');
                    
                    const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path1.setAttribute('d', 'M5,3L5,13L9,13L9,7L13,7L13,10L17,10L17,3L5,3Z');
                    path1.setAttribute('fill', '#0066cc');
                    
                    const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path2.setAttribute('d', 'M11,15L11,18L8,18L12,22L16,18L13,18L13,15L11,15Z');
                    path2.setAttribute('fill', '#0066cc');
                    
                    svg.appendChild(path1);
                    svg.appendChild(path2);
                    measureElement.appendChild(svg);
                    
                    // Add to slot
                    slot.appendChild(measureElement);
                    
                    // Update measurements data
                    const existing = measurements.findIndex(m => m.qubit === qubit);
                    if (existing !== -1) {
                        measurements[existing] = { qubit: qubit };
                    } else {
                        measurements.push({ qubit: qubit });
                    }
                    
                    // Add click handler to remove measurement
                    measureElement.addEventListener('click', function() {
                        slot.removeChild(measureElement);
                        // Remove from measurements data
                        const index = measurements.findIndex(m => m.qubit === qubit);
                        if (index !== -1) {
                            measurements.splice(index, 1);
                        }
                    });
                }
                
                function clearCircuit() {
                    // Clear all gate slots
                    const slots = document.querySelectorAll('.gate-slot');
                    slots.forEach(slot => {
                        while (slot.firstChild) {
                            slot.removeChild(slot.firstChild);
                        }
                    });
                    
                    // Clear all measurement slots
                    const measureSlots = document.querySelectorAll('.measurement-slot');
                    measureSlots.forEach(slot => {
                        while (slot.firstChild) {
                            slot.removeChild(slot.firstChild);
                        }
                    });
                    
                    // Clear circuit data
                    circuit = [];
                    measurements = [];
                    
                    // Clear results
                    document.getElementById('circuit-visualization').innerHTML = 
                        '<p class="placeholder-text">Circuitul va fi afișat aici după rulare...</p>';
                    document.getElementById('measurement-visualization').innerHTML = 
                        '<p class="placeholder-text">Rezultatele măsurătorilor vor fi afișate aici...</p>';
                    document.getElementById('statevector-visualization').innerHTML = 
                        '<p class="placeholder-text">Vectorul de stare va fi afișat aici...</p>';
                }
                
                function runCircuit() {
                    // Sort circuit by position
                    circuit.sort((a, b) => a.position - b.position);
                    
                    // Call API to run the circuit
                    const qubitCount = parseInt(qubitCountSelect.value);
                    
                    // For now, simulate API response - would be replaced with actual API call
                    simulateCircuitResponse(qubitCount, circuit, measurements);
                }
                
                function simulateCircuitResponse(qubitCount, circuit, measurements) {
                    // Display loading indicators
                    document.getElementById('circuit-visualization').innerHTML = 
                        '<div class="loading-animation"><div class="quantum-loading"></div><p>Se simulează circuitul...</p></div>';
                    document.getElementById('measurement-visualization').innerHTML = 
                        '<div class="loading-animation"><div class="quantum-loading"></div><p>Se calculează rezultatele...</p></div>';
                    document.getElementById('statevector-visualization').innerHTML = 
                        '<div class="loading-animation"><div class="quantum-loading"></div><p>Se calculează vectorul de stare...</p></div>';
                    
                    // Simulate API delay
                    setTimeout(() => {
                        // Generate circuit diagram (simplified version)
                        const circuitSvg = generateCircuitSvg(qubitCount, circuit, measurements);
                        document.getElementById('circuit-visualization').innerHTML = '';
                        document.getElementById('circuit-visualization').appendChild(circuitSvg);
                        
                        // Generate measurement results
                        const measurementResults = generateMeasurementResults(qubitCount, circuit, measurements);
                        document.getElementById('measurement-visualization').innerHTML = measurementResults;
                        
                        // Generate statevector representation
                        const statevectorHtml = generateStatevectorHtml(qubitCount, circuit);
                        document.getElementById('statevector-visualization').innerHTML = statevectorHtml;
                    }, 1500);
                }
                
                function generateCircuitSvg(qubitCount, circuit, measurements) {
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('width', '100%');
                    svg.setAttribute('height', qubitCount * 40 + 20);
                    svg.setAttribute('viewBox', `0 0 400 ${qubitCount * 40 + 20}`);
                    
                    // Draw qubit wires
                    for (let i = 0; i < qubitCount; i++) {
                        const y = 30 + i * 40;
                        
                        // Label
                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('x', '10');
                        text.setAttribute('y', y + 5);
                        text.setAttribute('font-size', '14');
                        text.textContent = `q${i}:`;
                        svg.appendChild(text);
                        
                        // Wire
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', '40');
                        line.setAttribute('y1', y);
                        line.setAttribute('x2', '360');
                        line.setAttribute('y2', y);
                        line.setAttribute('stroke', '#333');
                        line.setAttribute('stroke-width', '1');
                        svg.appendChild(line);
                    }
                    
                    // Draw gates
                    for (const gate of circuit) {
                        const x = 80 + gate.position * 60;
                        const y = 30 + gate.qubit * 40;
                        
                        // Gate rectangle
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', x - 15);
                        rect.setAttribute('y', y - 15);
                        rect.setAttribute('width', '30');
                        rect.setAttribute('height', '30');
                        rect.setAttribute('fill', '#0066cc');
                        rect.setAttribute('rx', '4');
                        svg.appendChild(rect);
                        
                        // Gate label
                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('x', x);
                        text.setAttribute('y', y + 5);
                        text.setAttribute('font-size', '12');
                        text.setAttribute('fill', 'white');
                        text.setAttribute('text-anchor', 'middle');
                        text.textContent = gate.gate;
                        svg.appendChild(text);
                    }
                    
                    // Draw measurements
                    for (const measure of measurements) {
                        const x = 340;
                        const y = 30 + measure.qubit * 40;
                        
                        // Measurement symbol
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', x - 15);
                        rect.setAttribute('y', y - 15);
                        rect.setAttribute('width', '30');
                        rect.setAttribute('height', '30');
                        rect.setAttribute('fill', '#e0e0e0');
                        rect.setAttribute('stroke', '#0066cc');
                        rect.setAttribute('stroke-width', '2');
                        rect.setAttribute('rx', '4');
                        svg.appendChild(rect);
                        
                        const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path1.setAttribute('d', `M${x-7},${y-7} L${x-7},${y+3} L${x-3},${y+3} L${x-3},${y-3} L${x+3},${y-3} L${x+3},${y} L${x+7},${y} L${x+7},${y-7} L${x-7},${y-7}`);
                        path1.setAttribute('fill', '#0066cc');
                        svg.appendChild(path1);
                        
                        const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path2.setAttribute('d', `M${x},${y+3} L${x},${y+7} L${x-3},${y+7} L${x},${y+10} L${x+3},${y+7} L${x},${y+7}`);
                        path2.setAttribute('fill', '#0066cc');
                        svg.appendChild(path2);
                    }
                    
                    return svg;
                }
                
                function generateMeasurementResults(qubitCount, circuit, measurements) {
                    if (measurements.length === 0) {
                        return '<p class="no-measurements">Nu au fost configurate măsurători.</p>';
                    }
                    
                    // Generate some simulated results based on the circuit
                    const results = {};
                    const shotCount = 1024;
                    
                    // Simplified simulation - just generate random results
                    // In a real implementation, this would be calculated from the circuit
                    
                    // For simple circuits, try to make it somewhat realistic
                    if (circuit.length === 0) {
                        // No gates, just |0⟩ states
                        results['0'.repeat(measurements.length)] = shotCount;
                    } else if (circuit.some(g => g.gate === 'H')) {
                        // If there's at least one H gate, create superposition
                        const resultCount = Math.min(Math.pow(2, measurements.length), 8);
                        const baseShots = Math.floor(shotCount / resultCount);
                        
                        for (let i = 0; i < resultCount; i++) {
                            const bitString = i.toString(2).padStart(measurements.length, '0');
                            results[bitString] = baseShots + Math.floor(Math.random() * 20);
                        }
                    } else {
                        // Some other circuit, generate a few results
                        const possibleResults = Math.min(4, Math.pow(2, measurements.length));
                        const mainResult = Math.floor(Math.random() * Math.pow(2, measurements.length));
                        
                        // Main result gets most shots
                        const mainBitString = mainResult.toString(2).padStart(measurements.length, '0');
                        results[mainBitString] = Math.floor(shotCount * 0.7);
                        
                        // Distribute remaining shots
                        const remainingShots = shotCount - results[mainBitString];
                        for (let i = 1; i < possibleResults; i++) {
                            let bitString;
                            do {
                                const resultValue = Math.floor(Math.random() * Math.pow(2, measurements.length));
                                bitString = resultValue.toString(2).padStart(measurements.length, '0');
                            } while (results[bitString]);
                            
                            results[bitString] = Math.floor(remainingShots / (possibleResults - 1));
                        }
                    }
                    
                    // Create the HTML for the histogram
                    let html = `<div class="result-summary">Rezultate pentru ${shotCount} execuții:</div>`;
                    html += '<div class="measurement-histogram">';
                    
                    // Sort results by bit string
                    const sortedResults = Object.entries(results).sort((a, b) => a[0].localeCompare(b[0]));
                    
                    for (const [bitString, count] of sortedResults) {
                        const percentage = (count / shotCount * 100).toFixed(1);
                        html += `
                            <div class="histogram-bar">
                                <div class="bar-label">${bitString}</div>
                                <div class="bar-container">
                                    <div class="bar-fill" style="width: ${percentage}%"></div>
                                </div>
                                <div class="bar-value">${count} (${percentage}%)</div>
                            </div>
                        `;
                    }
                    
                    html += '</div>';
                    return html;
                }
                
                function generateStatevectorHtml(qubitCount, circuit) {
                    if (circuit.length === 0) {
                        // Just |0⟩ state
                        return `
                            <div class="statevector-display">
                                <div class="statevector-entry selected">
                                    <div class="state-label">|${'0'.repeat(qubitCount)}⟩</div>
                                    <div class="amplitude">1.0</div>
                                </div>
                                ${Array(Math.pow(2, qubitCount) - 1).fill(0).map((_, i) => {
                                    const bitString = (i + 1).toString(2).padStart(qubitCount, '0');
                                    return `
                                        <div class="statevector-entry">
                                            <div class="state-label">|${bitString}⟩</div>
                                            <div class="amplitude">0.0</div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        `;
                    } else if (circuit.some(g => g.gate === 'H')) {
                        // If there's at least one H gate, create superposition
                        const hadamardQubits = new Set(circuit.filter(g => g.gate === 'H').map(g => g.qubit));
                        const stateCount = Math.pow(2, hadamardQubits.size);
                        const amplitude = (1 / Math.sqrt(stateCount)).toFixed(4);
                        
                        let html = '<div class="statevector-display">';
                        
                        for (let i = 0; i < Math.pow(2, qubitCount); i++) {
                            const bitString = i.toString(2).padStart(qubitCount, '0');
                            let isNonZero = true;
                            
                            // Check if this state should have non-zero amplitude
                            for (let q = 0; q < qubitCount; q++) {
                                if (!hadamardQubits.has(q) && bitString[qubitCount - 1 - q] === '1') {
                                    isNonZero = false;
                                    break;
                                }
                            }
                            
                            html += `
                                <div class="statevector-entry ${isNonZero ? 'selected' : ''}">
                                    <div class="state-label">|${bitString}⟩</div>
                                    <div class="amplitude">${isNonZero ? amplitude : '0.0'}</div>
                                </div>
                            `;
                        }
                        
                        html += '</div>';
                        return html;
                    } else if (circuit.some(g => g.gate === 'X')) {
                        // If there's X gates, flip bits
                        const flippedQubits = new Set(circuit.filter(g => g.gate === 'X').map(g => g.qubit));
                        let resultState = '0'.repeat(qubitCount);
                        
                        // Flip the bits
                        for (const qubit of flippedQubits) {
                            const bits = resultState.split('');
                            bits[qubitCount - 1 - qubit] = bits[qubitCount - 1 - qubit] === '0' ? '1' : '0';
                            resultState = bits.join('');
                        }
                        
                        return `
                            <div class="statevector-display">
                                ${Array(Math.pow(2, qubitCount)).fill(0).map((_, i) => {
                                    const bitString = i.toString(2).padStart(qubitCount, '0');
                                    const isSelected = bitString === resultState;
                                    return `
                                        <div class="statevector-entry ${isSelected ? 'selected' : ''}">
                                            <div class="state-label">|${bitString}⟩</div>
                                            <div class="amplitude">${isSelected ? '1.0' : '0.0'}</div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        `;
                    } else {
                        // Other circuits - simplified simulation
                        return `
                            <div class="statevector-complex">
                                <p>Vectorul de stare complet pentru acest circuit are ${Math.pow(2, qubitCount)} amplitudini.</p>
                                <p>Pentru a vizualiza reprezentarea completă, utilizați API-ul Qiskit sau descărcați rezultatele simulării.</p>
                            </div>
                        `;
                    }
                }
            }
        });
    </script>
    
    <style>
        /* Quantum Basics page specific styles */
        .principles-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            grid-gap: 2rem;
            margin: 2rem 0;
        }
        
        .principle-card {
            background-color: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
        }
        
        .principle-card h4 {
            color: #0066cc;
            margin-top: 0;
            margin-bottom: 1rem;
        }
        
        .principle-interactive {
            margin-top: 1.5rem;
            padding: 1rem;
            background-color: #f8f9fa;
            border-radius: 8px;
        }
        
        /* Superposition Demo */
        .qubit-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .qubit-sphere {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 2px solid #0066cc;
            position: relative;
            margin-bottom: 1rem;
            background: radial-gradient(circle at 30% 30%, #f0f7ff, #e0e0e0);
        }
        
        .qubit-state-marker {
            width: 10px;
            height: 10px;
            background-color: #f44336;
            border-radius: 50%;
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%) translateY(-50%) rotate(0deg) translateX(40px);
            transform-origin: center center;
            transition: transform 0.3s ease;
        }
        
        .qubit-controls {
            width: 100%;
            text-align: center;
        }
        
        .slider-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 0.5rem;
            color: #666;
            font-size: 0.8rem;
        }
        
        .state-display {
            margin-top: 1rem;
            padding: 1rem;
            background-color: white;
            border-radius: 8px;
            border: 1px solid #eee;
        }
        
        .quantum-state {
            font-family: 'Courier New', monospace;
            font-size: 1.2rem;
            margin: 0.5rem 0;
            text-align: center;
        }
        
        .state-formula {
            font-style: italic;
        }
        
        .state-probabilities {
            display: flex;
            justify-content: space-around;
            margin-top: 1rem;
        }
        
        .probability {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .probability span:last-child {
            font-weight: bold;
            color: #0066cc;
        }
        
        /* Interference Demo */
        .wave-container {
            margin-bottom: 1rem;
        }
        
        .quantum-wave {
            height: 80px;
            position: relative;
            margin-bottom: 0.5rem;
        }
        
        .wave-label {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 0.9rem;
            color: #666;
        }
        
        .quantum-wave.result {
            margin-top: 1rem;
            border-top: 1px dashed #ccc;
            padding-top: 1rem;
        }
        
        .wave-controls {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .wave-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .wave-control input {
            flex: 1;
        }
        
        .interference-info {
            text-align: center;
            font-weight: bold;
        }
        
        /* Entanglement Demo */
        .entangled-qubits {
            display: flex;
            align-items: center;
            justify-content: space-around;
            margin-bottom: 1.5rem;
        }
        
        .entangled-qubit {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .qubit-label {
            margin-bottom: 0.5rem;
            font-weight: bold;
        }
        
        .qubit-circle {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: #f0f7ff;
            border: 2px solid #0066cc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            transition: all 0.3s ease;
        }
        
        .qubit-circle.entangled {
            background-color: #e3f2fd;
            box-shadow: 0 0 10px rgba(0, 102, 204, 0.5);
            color: #0066cc;
        }
        
        .qubit-circle.measured {
            background-color: #e8f5e9;
            border-color: #4CAF50;
            color: #4CAF50;
            font-weight: bold;
        }
        
        .entanglement-line {
            flex: 1;
            height: 20px;
            max-width: 100px;
        }
        
        .measurement-result {
            margin-top: 0.5rem;
            min-height: 20px;
            color: #4CAF50;
            font-weight: bold;
        }
        
        .entanglement-controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        
        .entanglement-explanation {
            text-align: center;
            padding: 0.5rem;
            background-color: #f0f7ff;
            border-radius: 4px;
        }
        
        /* Gates Demo */
        .bloch-sphere-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        #bloch-sphere-display {
            width: 200px;
            height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #bloch-sphere-display img {
            max-width: 100%;
            max-height: 100%;
        }
        
        .state-notation {
            margin-top: 0.5rem;
            font-family: 'Courier New', monospace;
            font-size: 1.2rem;
        }
        
        .gates-controls {
            margin-top: 1rem;
        }
        
        .gates-selection {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .gate-button {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            background-color: #0066cc;
            color: white;
            border: none;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        
        .gate-button:hover {
            background-color: #0055aa;
        }
        
        .gates-info {
            padding: 0.5rem;
            background-color: #f0f7ff;
            border-radius: 4px;
            margin-bottom: 1rem;
        }
        
        #current-gate {
            font-weight: bold;
            margin-bottom: 0.5rem;
        }
        
        /* Applications Section */
        .applications-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            grid-gap: 2rem;
            margin: 2rem 0;
        }
        
        .application-card {
            text-align: center;
            background-color: #f8f9fa;
            padding: 2rem 1.5rem;
            border-radius: 8px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .application-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
        }
        
        .application-icon {
            width: 60px;
            height: 60px;
            margin: 0 auto 1.5rem;
            background-repeat: no-repeat;
            background-position: center;
            background-size: contain;
        }
        
        .cryptography-icon {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%230066cc"><path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"/></svg>');
        }
        
        .chemistry-icon {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%230066cc"><path d="M19 8h-2v3h-3v2h3v3h2v-3h3v-2h-3V8z"/><path d="M3 8h4v2H3v8h14v-2H5v-4h3v-2H3V8z"/></svg>');
        }
        
        .optimization-icon {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%230066cc"><path d="M3 3v18h18V3H3zm4 2h10v10H7V5z"/><path d="M10 12l1-2 1 1 3-4 1 3-1 2-1-1-4 3z"/></svg>');
        }
        
        .ai-icon {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%230066cc"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 16c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z"/><path d="M9 9h6v6H9z"/></svg>');
        }
        
        .application-card h4 {
            color: #0066cc;
            margin-bottom: 1rem;
        }
        
        /* Circuit Builder */
        .circuit-builder-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-gap: 2rem;
            margin: 2rem 0;
        }
        
        .circuit-design {
            background-color: #f8f9fa;
            padding: 1.5rem;
            border-radius: 8px;
        }
        
        .qubits-selection {
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .qubits-selection select {
            padding: 0.5rem;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        
        .circuit-grid {
            background-color: white;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
            border: 1px solid #eee;
            display: grid;
            grid-template-columns: auto 1fr auto;
            grid-template-rows: auto auto;
            grid-template-areas: 
                "labels wires measurements"
                "slots slots slots";
        }
        
        .circuit-labels {
            grid-area: labels;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
        }
        
        .circuit-wires {
            grid-area: wires;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
        }
        
        .circuit-wire {
            height: 2px;
            background-color: #666;
            margin: 1.5rem 0;
        }
        
        .gate-slots {
            grid-area: slots;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
        }
        
        .gate-slot {
            height: 40px;
            border: 2px dashed #ccc;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .gate-slot.dragover {
            background-color: #e3f2fd;
            border-color: #0066cc;
        }
        
        .measurement-slots {
            grid-area: measurements;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
        }
        
        .measurement-slot {
            width: 40px;
            height: 40px;
            border: 2px dashed #ccc;
            border-radius: 4px;
            margin: 0.5rem 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .measurement-slot.dragover {
            background-color: #e3f2fd;
            border-color: #0066cc;
        }
        
        .gate-palette {
            margin-bottom: 1.5rem;
        }
        
        .gate-category {
            margin-bottom: 1rem;
        }
        
        .gate-category h4 {
            font-size: 1rem;
            margin-bottom: 0.5rem;
            color: #666;
        }
        
        .gates {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .draggable-gate {
            width: 40px;
            height: 40px;
            background-color: #0066cc;
            color: white;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: grab;
            transition: background-color 0.2s ease;
        }
        
        .draggable-gate:hover {
            background-color: #0055aa;
        }
        
        .draggable-gate.multi-qubit {
            width: auto;
            padding: 0 0.5rem;
        }
        
        .circuit-gate {
            width: 100%;
            height: 100%;
            background-color: #0066cc;
            color: white;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
        }
        
        .measurement-gate {
            width: 100%;
            height: 100%;
            background-color: #e0e0e0;
            border: 2px solid #0066cc;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        
        .circuit-actions {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
        }
        
        .simulation-results {
            background-color: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
        }
        
        .results-container {
            display: grid;
            grid-template-rows: auto auto auto;
            gap: 1.5rem;
            margin-top: 1rem;
        }
        
        .circuit-visualization,
        .measurement-results,
        .state-vector {
            background-color: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
        }
        
        .placeholder-text {
            color: #999;
            font-style: italic;
            text-align: center;
        }
        
        .loading-animation {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100px;
        }
        
        .quantum-loading {
            width: 30px;
            height: 30px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #0066cc;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .result-summary {
            margin-bottom: 1rem;
            font-weight: bold;
            color: #0066cc;
        }
        
        .measurement-histogram {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .histogram-bar {
            display: grid;
            grid-template-columns: 50px 1fr 80px;
            align-items: center;
            gap: 0.5rem;
        }
        
        .bar-label {
            font-family: 'Courier New', monospace;
            text-align: center;
        }
        
        .bar-container {
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .bar-fill {
            height: 100%;
            background-color: #0066cc;
            transition: width 1s ease;
        }
        
        .bar-value {
            font-size: 0.9rem;
            color: #666;
        }
        
        .statevector-display {
            max-height: 200px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .statevector-entry {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem;
            border-radius: 4px;
            transition: background-color 0.3s ease;
        }
        
        .statevector-entry.selected {
            background-color: #e3f2fd;
        }
        
        .state-label {
            font-family: 'Courier New', monospace;
        }
        
        .amplitude {
            font-weight: bold;
        }
        
        .statevector-complex {
            padding: 1rem;
            background-color: #f0f7ff;
            border-radius: 8px;
            border-left: 4px solid #0066cc;
        }
        
        .quantum-button {
            background-color: #0066cc;
            color: white;
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            font-weight: 500;
        }
        
        .quantum-button:hover {
            background-color: #0055aa;
        }
        
        .quantum-button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .quantum-button.secondary {
            background-color: #e0e0e0;
            color: #333;
        }
        
        .quantum-button.secondary:hover {
            background-color: #ccc;
        }
        
        /* Resources Section */
        .resources-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            grid-gap: 2rem;
            margin: 2rem 0;
        }
        
        .resource-item {
            background-color: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            display: flex;
            gap: 1rem;
        }
        
        .resource-icon {
            width: 50px;
            height: 50px;
            background-repeat: no-repeat;
            background-position: center;
            background-size: contain;
            flex-shrink: 0;
        }
        
        .book-icon {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%230066cc"><path d="M17.5 4.5c-1.95 0-4.05 0.4-5.5 1.5-1.45-1.1-3.55-1.5-5.5-1.5-1.45 0-2.99 0.22-4.28 0.79C0.88 5.76 0 7.09 0 8.58v8.45c0 0.93 0.42 1.77 1.41 2.08 0.95 0.3 1.87 0.52 2.79 0.67 0.66 0.11 1.45 0.24 2.31 0.24 1.24 0 2.46-0.25 3.54-0.95C11.03 19.5 11 20 11 20.5v1l2-0.5v-1c0-0.5 0-1-1-1.5 1.08 0.7 2.3 0.95 3.54 0.95 0.86 0 1.65-0.13 2.31-0.24 0.92-0.15 1.84-0.37 2.79-0.67 0.99-0.31 1.41-1.17 1.41-2.08v-8.46c0-1.46-0.8-2.77-2.28-3.42C18.5 4.5 17.5 4.5 17.5 4.5zM21 17.1c0 0.57-0.74 0.89-1.64 1.18-0.86 0.26-1.61 0.35-2.36 0.35-1.4 0-3.5-0.5-5-2.4v-8.1c1.5 1.73 3.5 2.37 5 2.37 0.75 0 1.5-0.09 2.36-0.35 0.89-0.29 1.64-0.63 1.64-1.19V17.1zM3 17.1v-8.1c0 0.54 0.65 0.9 1.64 1.19 0.86 0.26 1.61 0.35 2.36 0.35 1.5 0 3.5-0.64 5-2.37v8.1c-1.5 1.9-3.6 2.4-5 2.4-0.75 0-1.5-0.09-2.36-0.35C3.65 18 3 17.66 3 17.1z"/></svg>');
        }
        
        .video-icon {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%230066cc"><path d="M21 3H3c-1.11 0-2 .89-2 2v12c0 1.1.89 2 2 2h5v2h8v-2h5c1.1 0 1.99-.9 1.99-2L22 5c0-1.11-.9-2-2-2zm0 14H3V5h18v12z"/><path d="M10 8l6 4l-6 4z"/></svg>');
        }
        
        .course-icon {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%230066cc"><path d="M5 13.18v4L12 21l7-3.82v-4L12 17l-7-3.82zM12 3L1 9l11 6 9-4.91V17h2V9L12 3z"/></svg>');
        }
        
        .resource-content {
            flex: 1;
        }
        
        .resource-content h4 {
            color: #0066cc;
            margin-top: 0;
            margin-bottom: 1rem;
        }
        
        .resource-content ul {
            margin: 0;
            padding-left: 1.5rem;
        }
        
        .resource-content li {
            margin-bottom: 0.5rem;
        }
        
        .resource-content a {
            color: #0066cc;
            text-decoration: none;
        }
        
        .resource-content a:hover {
            text-decoration: underline;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .circuit-builder-container {
                grid-template-columns: 1fr;
            }
            
            .histogram-bar {
                grid-template-columns: 40px 1fr 70px;
            }
        }
    </style>
</body>
</html>