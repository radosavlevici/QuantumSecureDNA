<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Ervin Remus Radosavlevici (ervin210@icloud.com)">
    <meta name="copyright" content="© 2025 Ervin Remus Radosavlevici (ervin210@icloud.com) - Toate drepturile rezervate">
    <meta name="description" content="Algoritmi Cuantici - Quantum Computing Academy">
    <title>Algoritmi Cuantici - Quantum Computing Academy</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/main.css') }}">
</head>
<body>
    <header>
        <nav class="main-nav">
            <div class="logo">
                <h1>Quantum Computing Academy</h1>
                <span class="copyright-tag">© 2025 Ervin Remus Radosavlevici</span>
            </div>
            <ul class="nav-links">
                <li><a href="{{ url_for('index') }}">Acasă</a></li>
                <li><a href="{{ url_for('quantum_basics') }}">Noțiuni de Bază</a></li>
                <li><a href="{{ url_for('quantum_algorithms') }}" class="active">Algoritmi Cuantici</a></li>
                <li><a href="{{ url_for('quantum_ml') }}">Cuantic & ML</a></li>
                <li><a href="{{ url_for('dna_security_page') }}">Securitate ADN</a></li>
                <li><a href="{{ url_for('resources') }}">Resurse</a></li>
                <li><a href="{{ url_for('login_page') }}" class="btn-login">Autentificare</a></li>
            </ul>
        </nav>
    </header>

    <main>
        <section class="page-header">
            <h2>Algoritmi Cuantici</h2>
            <p>Explorați algoritmii cuantici fundamentali cu demonstrații interactive și vizualizări detaliate.</p>
            <div class="security-badge">
                <span class="security-key">Cheie de securitate: {{ security_key }}</span>
                <span class="security-info">Protejat prin tehnologie cuantică și ADN</span>
            </div>
        </section>

        <section class="algorithms-intro">
            <h3>Introducere în Algoritmi Cuantici</h3>
            <p>Algoritmii cuantici sunt secvențe de operații cuantice care utilizează proprietățile mecanicii cuantice, precum superpoziția și înlănțuirea, pentru a rezolva probleme care sunt dificil de abordat cu calculatoarele clasice. Acești algoritmi pot oferi accelerări exponențiale pentru anumite probleme, revoluționând domenii precum criptografia, optimizarea și simulările.</p>
            
            <div class="advantage-cards">
                <div class="advantage-card">
                    <h4>Avantaj Cuantic</h4>
                    <p>Calculul cuantic poate rezolva anumite probleme exponențial mai rapid decât calculul clasic datorită capacității de a manipula stări cuantice.</p>
                    <div class="complexity-comparison">
                        <div class="complexity">
                            <div class="complexity-label">Algoritm Clasic</div>
                            <div class="complexity-value">O(2<sup>n</sup>)</div>
                        </div>
                        <div class="complexity-vs">vs</div>
                        <div class="complexity">
                            <div class="complexity-label">Algoritm Cuantic</div>
                            <div class="complexity-value">O(n<sup>2</sup>)</div>
                        </div>
                    </div>
                </div>
                <div class="advantage-card">
                    <h4>Paralelism Cuantic</h4>
                    <p>Calculatoarele cuantice pot evalua multiple soluții simultan datorită superpoziției, oferind o creștere substanțială a puterii de calcul.</p>
                    <div class="parallelism-visual">
                        <div class="classical-computation">
                            <div class="computation-label">Clasic</div>
                            <div class="computation-path">
                                <div class="path-step">→</div>
                                <div class="path-step">→</div>
                                <div class="path-step">→</div>
                                <div class="path-step">→</div>
                            </div>
                        </div>
                        <div class="quantum-computation">
                            <div class="computation-label">Cuantic</div>
                            <div class="computation-paths">
                                <div class="path-step">↗</div>
                                <div class="path-step">↗</div>
                                <div class="path-step">↗</div>
                                <div class="path-step">↘</div>
                                <div class="path-step">→</div>
                                <div class="path-step">→</div>
                                <div class="path-step">→</div>
                                <div class="path-step">↘</div>
                                <div class="path-step">↗</div>
                                <div class="path-step">↗</div>
                                <div class="path-step">↗</div>
                                <div class="path-step">↘</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="algorithm-showcase">
            <div class="algorithm-tabs">
                <button class="algorithm-tab active" data-algorithm="deutsch-jozsa">Deutsch-Jozsa</button>
                <button class="algorithm-tab" data-algorithm="grover">Grover</button>
                <button class="algorithm-tab" data-algorithm="shor">Shor</button>
                <button class="algorithm-tab" data-algorithm="qft">QFT</button>
            </div>
            
            <div class="algorithm-content">
                <!-- Deutsch-Jozsa Algorithm -->
                <div class="algorithm-details active" id="deutsch-jozsa-content">
                    <h3>Algoritmul Deutsch-Jozsa</h3>
                    <div class="algorithm-description">
                        <p>Algoritmul Deutsch-Jozsa demonstrează avantajul cuantic rezolvând o problemă specifică cu o singură interogare, în timp ce un calculator clasic ar necesita 2<sup>n-1</sup>+1 interogări în cel mai rău caz.</p>
                        <h4>Problema</h4>
                        <p>Dată fiind o funcție f(x) care returnează 0 sau 1 pentru orice șir de biți x, determinați dacă funcția este constantă (returnează mereu același rezultat) sau echilibrată (returnează 0 pentru jumătate din inputuri și 1 pentru cealaltă jumătate).</p>
                    </div>
                    
                    <div class="algorithm-interactive">
                        <div class="interactive-deutsch">
                            <div class="deutsch-controls">
                                <h4>Selectați tipul funcției</h4>
                                <div class="function-selection">
                                    <label>
                                        <input type="radio" name="function-type" value="constant-0" checked>
                                        Constantă (mereu 0)
                                    </label>
                                    <label>
                                        <input type="radio" name="function-type" value="constant-1">
                                        Constantă (mereu 1)
                                    </label>
                                    <label>
                                        <input type="radio" name="function-type" value="balanced-1">
                                        Echilibrată (tip 1)
                                    </label>
                                    <label>
                                        <input type="radio" name="function-type" value="balanced-2">
                                        Echilibrată (tip 2)
                                    </label>
                                </div>
                                <div class="deutsch-qubits">
                                    <label for="deutsch-qubit-count">Număr de qubiți: </label>
                                    <select id="deutsch-qubit-count">
                                        <option value="2">2 qubiți</option>
                                        <option value="3">3 qubiți</option>
                                        <option value="4">4 qubiți</option>
                                    </select>
                                </div>
                                <button id="run-deutsch" class="run-algorithm">Rulează algoritmul</button>
                            </div>
                            
                            <div class="algorithm-visualization">
                                <div id="deutsch-circuit" class="circuit-diagram">
                                    <p class="placeholder-text">Circuitul va fi afișat aici după rulare...</p>
                                </div>
                                <div class="algorithm-results">
                                    <h4>Rezultat</h4>
                                    <div id="deutsch-result" class="result-display">
                                        <p class="placeholder-text">Rezultatul va fi afișat aici...</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="algorithm-explanation">
                        <h4>Cum funcționează</h4>
                        <ol>
                            <li><strong>Inițializare:</strong> Se pregătesc n+1 qubiți în starea |0⟩, apoi se aplică poarta Hadamard pe toți qubiții pentru a crea superpoziția tuturor stărilor posibile.</li>
                            <li><strong>Aplicarea oracolului:</strong> Se aplică funcția f(x) căreia dorim să-i determinăm tipul (constantă sau echilibrată).</li>
                            <li><strong>Aplicarea inversei transformării Hadamard:</strong> Se aplică din nou porți Hadamard pe primii n qubiți.</li>
                            <li><strong>Măsurarea:</strong> Se măsoară primii n qubiți. Dacă toți sunt în starea |0⟩, funcția este constantă. Altfel, funcția este echilibrată.</li>
                        </ol>
                        <p>Puterea algoritmului constă în faptul că determină rezultatul cu o singură evaluare a funcției, indiferent de dimensiunea intrării!</p>
                    </div>
                </div>
                
                <!-- Grover's Algorithm -->
                <div class="algorithm-details" id="grover-content">
                    <h3>Algoritm de Căutare Grover</h3>
                    <div class="algorithm-description">
                        <p>Algoritmul Grover oferă o accelerare pătratică pentru căutarea într-o bază de date nestructurată, o problemă clasică care necesită O(N) pași, dar poate fi rezolvată în O(√N) pași cu calculul cuantic.</p>
                        <h4>Problema</h4>
                        <p>Dată fiind o listă neordonată de N elemente, găsiți un element specific sau un element care satisface o anumită condiție, fără a avea informații suplimentare despre structura datelor.</p>
                    </div>
                    
                    <div class="algorithm-interactive">
                        <div class="interactive-grover">
                            <div class="grover-controls">
                                <h4>Configurare Algoritm Grover</h4>
                                <div class="target-selection">
                                    <label for="grover-database-size">Dimensiunea bazei de date: </label>
                                    <select id="grover-database-size">
                                        <option value="4">4 elemente (2 qubiți)</option>
                                        <option value="8">8 elemente (3 qubiți)</option>
                                        <option value="16">16 elemente (4 qubiți)</option>
                                    </select>
                                </div>
                                <div class="target-selection">
                                    <label>Element căutat: </label>
                                    <div id="target-options" class="target-options">
                                        <button class="target-option" data-target="0">0</button>
                                        <button class="target-option" data-target="1">1</button>
                                        <button class="target-option" data-target="2">2</button>
                                        <button class="target-option selected" data-target="3">3</button>
                                    </div>
                                </div>
                                <button id="run-grover" class="run-algorithm">Pornește căutarea</button>
                            </div>
                            
                            <div class="algorithm-visualization">
                                <div class="grover-animation">
                                    <div class="database-visualization">
                                        <h4>Baza de date (amplitudini)</h4>
                                        <div id="database-items" class="database-items">
                                            <!-- Items will be generated dynamically -->
                                        </div>
                                    </div>
                                    <div class="iterations-control">
                                        <button id="next-iteration" class="iteration-btn" disabled>Următoarea iterație</button>
                                        <span id="iteration-count">Iterația: 0 / 0</span>
                                    </div>
                                </div>
                                <div class="algorithm-results">
                                    <h4>Rezultat final</h4>
                                    <div id="grover-result" class="result-display">
                                        <p class="placeholder-text">Rezultatul măsurătorii va fi afișat aici...</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="algorithm-explanation">
                        <h4>Cum funcționează</h4>
                        <ol>
                            <li><strong>Inițializare:</strong> Se pregătesc n qubiți în starea |0⟩, apoi se aplică poarta Hadamard pe toți qubiții pentru a crea o superpoziție uniformă.</li>
                            <li><strong>Amplificare a amplitudinii:</strong> Se repetă următorii pași de aproximativ π√N/4 ori:
                                <ul>
                                    <li>Se aplică oracolul care inversează faza (semnul) amplitudinii stării căutate.</li>
                                    <li>Se aplică operatorul de difuziune (reflexie față de medie) care amplifică amplitudinea stării căutate și le reduce pe celelalte.</li>
                                </ul>
                            </li>
                            <li><strong>Măsurare:</strong> Se măsoară starea sistemului, obținând rezultatul căutat cu probabilitate ridicată.</li>
                        </ol>
                        <p>Cu fiecare iterație, amplitudinea stării căutate crește, în timp ce amplitudinile celorlalte stări scad, astfel încât la final, măsurarea va produce starea căutată cu probabilitate apropiată de 1.</p>
                    </div>
                </div>
                
                <!-- Shor's Algorithm -->
                <div class="algorithm-details" id="shor-content">
                    <h3>Algoritmul lui Shor</h3>
                    <div class="algorithm-description">
                        <p>Algoritmul lui Shor reprezintă una din cele mai importante descoperiri în informatica cuantică, oferind o metodă eficientă pentru factorizarea numerelor mari în timp polinomial, ceea ce amenință sistemele criptografice moderne bazate pe RSA.</p>
                        <h4>Problema</h4>
                        <p>Factorizarea unui număr întreg N în factori primi. Pentru numerele mari, cel mai bun algoritm clasic cunoscut rulează în timp subexponențial, în timp ce algoritmul lui Shor rulează în timp polinomial.</p>
                    </div>
                    
                    <div class="algorithm-interactive">
                        <div class="interactive-shor">
                            <div class="shor-controls">
                                <h4>Demonstrație Shor</h4>
                                <div class="number-input">
                                    <label for="number-to-factorize">Număr de factorizat:</label>
                                    <select id="number-to-factorize">
                                        <option value="15">15 (demonstrație)</option>
                                        <option value="21">21 (demonstrație)</option>
                                        <option value="35">35 (demonstrație)</option>
                                    </select>
                                </div>
                                <button id="run-shor" class="run-algorithm">Factorizează</button>
                            </div>
                            
                            <div class="algorithm-visualization">
                                <div class="shor-steps">
                                    <div class="shor-step">
                                        <h5>Pasul 1: Transformare în găsirea perioadei</h5>
                                        <div id="shor-step1" class="step-content">
                                            <p class="placeholder-text">Informațiile vor fi afișate după rulare...</p>
                                        </div>
                                    </div>
                                    <div class="shor-step">
                                        <h5>Pasul 2: Estimarea perioadei cu QFT</h5>
                                        <div id="shor-step2" class="step-content">
                                            <p class="placeholder-text">Informațiile vor fi afișate după rulare...</p>
                                        </div>
                                    </div>
                                    <div class="shor-step">
                                        <h5>Pasul 3: Calcularea factorilor</h5>
                                        <div id="shor-step3" class="step-content">
                                            <p class="placeholder-text">Informațiile vor fi afișate după rulare...</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="algorithm-results">
                                    <h4>Rezultat factorizare</h4>
                                    <div id="shor-result" class="result-display">
                                        <p class="placeholder-text">Rezultatul factorizării va fi afișat aici...</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="algorithm-explanation">
                        <h4>Cum funcționează</h4>
                        <ol>
                            <li><strong>Reducere la găsirea perioadei:</strong> Problema factorizării este redusă la găsirea perioadei funcției f(x) = a<sup>x</sup> mod N, unde a este un număr aleator coprim cu N.</li>
                            <li><strong>Estimarea perioadei utilizând QFT:</strong> Se utilizează Transformata Fourier Cuantică pentru a găsi perioada r a funcției f(x).</li>
                            <li><strong>Calcul clasic final:</strong> Din perioada r, se calculează factorii lui N utilizând cel mai mare divizor comun: gcd(a<sup>r/2</sup> - 1, N) și gcd(a<sup>r/2</sup> + 1, N).</li>
                        </ol>
                        <p>Algoritmul lui Shor arată potențialul calculatoarelor cuantice de a rezolva probleme considerate intractabile pentru calculatoarele clasice, având implicații majore pentru securitatea informatică și criptografie.</p>
                    </div>
                </div>
                
                <!-- Quantum Fourier Transform -->
                <div class="algorithm-details" id="qft-content">
                    <h3>Transformata Fourier Cuantică (QFT)</h3>
                    <div class="algorithm-description">
                        <p>Transformata Fourier Cuantică (QFT) este o transformare unitară fundamentală în calculul cuantic, fiind echivalentul cuantic al Transformatei Fourier Discrete. QFT este folosită ca subrutină în numeroși algoritmi, inclusiv algoritmul lui Shor.</p>
                        <h4>Aplicații</h4>
                        <p>QFT permite conversia între reprezentarea în bază de calcul și reprezentarea în bază Fourier, fiind esențială pentru găsirea periodicității și a structurilor ascunse în date cuantice.</p>
                    </div>
                    
                    <div class="algorithm-interactive">
                        <div class="interactive-qft">
                            <div class="qft-controls">
                                <h4>Demonstrație QFT</h4>
                                <div class="input-selection">
                                    <label for="qft-input-state">Stare inițială:</label>
                                    <select id="qft-input-state">
                                        <option value="basis">Stare de bază |0...0⟩</option>
                                        <option value="uniform">Superpoziție uniformă</option>
                                        <option value="periodic">Funcție periodică</option>
                                        <option value="custom">Personalizată</option>
                                    </select>
                                </div>
                                <div id="custom-state-config" class="custom-state-config" style="display: none;">
                                    <div class="custom-amplitudes">
                                        <!-- Will be populated dynamically -->
                                    </div>
                                </div>
                                <div class="qubit-selection">
                                    <label for="qft-qubit-count">Număr de qubiți:</label>
                                    <select id="qft-qubit-count">
                                        <option value="3">3 qubiți</option>
                                        <option value="4">4 qubiți</option>
                                        <option value="5">5 qubiți</option>
                                    </select>
                                </div>
                                <button id="run-qft" class="run-algorithm">Aplică QFT</button>
                            </div>
                            
                            <div class="algorithm-visualization">
                                <div class="qft-visualization">
                                    <div class="state-visualization">
                                        <h5>Stare inițială</h5>
                                        <div id="initial-state" class="state-display">
                                            <!-- Will be populated dynamically -->
                                        </div>
                                    </div>
                                    <div class="qft-arrow">
                                        <svg width="50" height="50" viewBox="0 0 50 50">
                                            <path d="M10,25 L40,25 M35,20 L40,25 L35,30" fill="none" stroke="#0066cc" stroke-width="2" />
                                            <text x="25" y="15" text-anchor="middle" fill="#0066cc" font-size="12">QFT</text>
                                        </svg>
                                    </div>
                                    <div class="state-visualization">
                                        <h5>Stare după QFT</h5>
                                        <div id="qft-state" class="state-display">
                                            <!-- Will be populated dynamically -->
                                        </div>
                                    </div>
                                </div>
                                <div class="qft-circuit">
                                    <h5>Circuitul QFT</h5>
                                    <div id="qft-circuit" class="circuit-diagram">
                                        <p class="placeholder-text">Circuitul va fi afișat după rulare...</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="algorithm-explanation">
                        <h4>Cum funcționează</h4>
                        <p>Pentru un registru cuantic cu n qubiți, QFT transformă starea |j⟩ în:</p>
                        <div class="math-formula">
                            QFT|j⟩ = \frac{1}{\sqrt{2^n}} \sum_{k=0}^{2^n-1} e^{2\pi i jk/2^n} |k⟩
                        </div>
                        <p>Implementarea circuitului QFT utilizează:</p>
                        <ul>
                            <li><strong>Porți Hadamard:</strong> Aplicate pe fiecare qubit pentru a crea superpoziție.</li>
                            <li><strong>Porți de fază controlate:</strong> Realizează rotațiile de fază necesare.</li>
                            <li><strong>Inversare de ordine:</strong> Opțional, qubiții sunt inversați la final pentru a respecta convenția standard.</li>
                        </ul>
                        <p>QFT cuantică necesită doar O(n²) porți, în contrast cu O(n 2<sup>n</sup>) operații necesare pentru FFT clasică, demonstrând un avantaj exponențial.</p>
                    </div>
                </div>
            </div>
        </section>

        <section class="algorithm-comparison">
            <h3>Comparație Algoritmi Clasici vs. Cuantici</h3>
            <div class="comparison-table-container">
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Problema</th>
                            <th>Algoritm Clasic</th>
                            <th>Algoritm Cuantic</th>
                            <th>Accelerare</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Căutare în bază de date neordonată</td>
                            <td>O(N)</td>
                            <td>O(√N) - Grover</td>
                            <td>Pătratică</td>
                        </tr>
                        <tr>
                            <td>Factorizare numere întregi</td>
                            <td>O(e<sup>(log N)<sup>1/3</sup> (log log N)<sup>2/3</sup></sup>) - NFS</td>
                            <td>O((log N)<sup>2</sup> (log log N) (log log log N)) - Shor</td>
                            <td>Exponențială</td>
                        </tr>
                        <tr>
                            <td>Simulare sisteme cuantice</td>
                            <td>O(e<sup>N</sup>)</td>
                            <td>O(N<sup>2</sup>)</td>
                            <td>Exponențială</td>
                        </tr>
                        <tr>
                            <td>Transformata Fourier</td>
                            <td>O(N log N) - FFT</td>
                            <td>O((log N)<sup>2</sup>) - QFT</td>
                            <td>Exponențială</td>
                        </tr>
                        <tr>
                            <td>Funcții booleene constante/echilibrate</td>
                            <td>O(2<sup>n-1</sup>+1)</td>
                            <td>O(1) - Deutsch-Jozsa</td>
                            <td>Exponențială</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p class="comparison-note">* NFS = Number Field Sieve, cel mai rapid algoritm clasic cunoscut pentru factorizare</p>
        </section>
        
        <section class="algorithm-resources">
            <h3>Resurse și Referințe</h3>
            <div class="resources-grid">
                <div class="resource-card">
                    <h4>Lectură Aprofundată</h4>
                    <ul class="resource-list">
                        <li><a href="#">"Quantum Computation and Quantum Information" - Nielsen & Chuang</a></li>
                        <li><a href="#">"Quantum Algorithms via Linear Algebra" - Lipton & Regan</a></li>
                        <li><a href="#">"An Introduction to Quantum Computing" - Kaye, Laflamme & Mosca</a></li>
                    </ul>
                </div>
                <div class="resource-card">
                    <h4>Tutoriale Interactive</h4>
                    <ul class="resource-list">
                        <li><a href="#">Implementarea algoritmului Grover în Qiskit</a></li>
                        <li><a href="#">Ghid pas cu pas pentru algoritmul Deutsch-Jozsa</a></li>
                        <li><a href="#">Simularea QFT pentru diferite stări de intrare</a></li>
                    </ul>
                </div>
                <div class="resource-card">
                    <h4>Articole Științifice</h4>
                    <ul class="resource-list">
                        <li><a href="#">"Polynomial-Time Algorithms for Prime Factorization and Discrete Logarithms on a Quantum Computer" - Peter Shor (1994)</a></li>
                        <li><a href="#">"Quantum Complexity Theory" - Bernstein & Vazirani (1993)</a></li>
                        <li><a href="#">"A Fast Quantum Mechanical Algorithm for Database Search" - Lov Grover (1996)</a></li>
                    </ul>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <div class="footer-content">
            <div class="footer-copyright">
                <p>© 2025 Ervin Remus Radosavlevici (ervin210@icloud.com)</p>
                <p>Toate drepturile rezervate global. Protejat de legile internaționale ale drepturilor de autor.</p>
            </div>
            <div class="footer-security">
                <p>Securizat cu tehnologie cuantică și ADN</p>
                <p>Cheie de Securitate: {{ security_key }}</p>
            </div>
            <div class="footer-links">
                <ul>
                    <li><a href="{{ url_for('quantum_basics') }}">Noțiuni de Bază</a></li>
                    <li><a href="{{ url_for('quantum_algorithms') }}">Algoritmi Cuantici</a></li>
                    <li><a href="{{ url_for('dna_security_page') }}">Securitate ADN</a></li>
                    <li><a href="{{ url_for('resources') }}">Resurse</a></li>
                </ul>
            </div>
        </div>
    </footer>

    <script src="{{ url_for('static', filename='js/security.js') }}"></script>
    <script src="{{ url_for('static', filename='js/breach-detector.js') }}"></script>
    <script src="{{ url_for('static', filename='js/quantum_visuals.js') }}"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Algorithm tabs switching
            const algorithmTabs = document.querySelectorAll('.algorithm-tab');
            const algorithmContents = document.querySelectorAll('.algorithm-details');
            
            algorithmTabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    const algorithm = this.getAttribute('data-algorithm');
                    
                    // Update active tab
                    algorithmTabs.forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Show corresponding content
                    algorithmContents.forEach(content => {
                        content.classList.remove('active');
                    });
                    document.getElementById(`${algorithm}-content`).classList.add('active');
                });
            });
            
            // Deutsch-Jozsa Algorithm Interactive
            initializeDeutschJozsa();
            
            // Grover's Algorithm Interactive
            initializeGrover();
            
            // Shor's Algorithm Interactive
            initializeShor();
            
            // QFT Interactive
            initializeQFT();
            
            // Deutsch-Jozsa Implementation
            function initializeDeutschJozsa() {
                const qubitCountSelect = document.getElementById('deutsch-qubit-count');
                const runButton = document.getElementById('run-deutsch');
                const functionRadios = document.querySelectorAll('input[name="function-type"]');
                
                runButton.addEventListener('click', function() {
                    const qubitCount = parseInt(qubitCountSelect.value);
                    let functionType = '';
                    
                    functionRadios.forEach(radio => {
                        if (radio.checked) {
                            functionType = radio.value;
                        }
                    });
                    
                    runDeutschJozsa(qubitCount, functionType);
                });
                
                function runDeutschJozsa(qubitCount, functionType) {
                    // Show loading state
                    document.getElementById('deutsch-circuit').innerHTML = 
                        '<div class="loading-animation"><div class="quantum-loading"></div><p>Se simulează circuitul...</p></div>';
                    document.getElementById('deutsch-result').innerHTML = 
                        '<div class="loading-animation"><div class="quantum-loading"></div><p>Se calculează rezultatul...</p></div>';
                    
                    // Simulate delay for API call
                    setTimeout(() => {
                        // Generate circuit visualization
                        const circuitSvg = generateDeutschCircuit(qubitCount, functionType);
                        document.getElementById('deutsch-circuit').innerHTML = '';
                        document.getElementById('deutsch-circuit').appendChild(circuitSvg);
                        
                        // Determine result based on function type
                        let resultHtml = '';
                        if (functionType.startsWith('constant')) {
                            resultHtml = `
                                <div class="algorithm-result-box success">
                                    <h5>Funcție Constantă Detectată!</h5>
                                    <p>Toți qubiții de măsurare sunt în starea |0⟩, confirmând că funcția selectată este constantă.</p>
                                    <div class="result-details">
                                        <p>Funcția selectată: ${functionType === 'constant-0' ? 'f(x) = 0 pentru orice x' : 'f(x) = 1 pentru orice x'}</p>
                                        <p>Număr de evaluări cuantice: 1</p>
                                        <p>Număr de evaluări clasice necesare: ${Math.pow(2, qubitCount-1) + 1}</p>
                                    </div>
                                </div>
                            `;
                        } else {
                            resultHtml = `
                                <div class="algorithm-result-box warning">
                                    <h5>Funcție Echilibrată Detectată!</h5>
                                    <p>Cel puțin un qubit de măsurare este în starea |1⟩, confirmând că funcția selectată este echilibrată.</p>
                                    <div class="result-details">
                                        <p>Funcția selectată: Echilibrată (returnează 0 și 1 pentru un număr egal de intrări)</p>
                                        <p>Număr de evaluări cuantice: 1</p>
                                        <p>Număr de evaluări clasice necesare: ${Math.pow(2, qubitCount-1) + 1}</p>
                                    </div>
                                </div>
                            `;
                        }
                        
                        document.getElementById('deutsch-result').innerHTML = resultHtml;
                    }, 1500);
                }
                
                function generateDeutschCircuit(qubitCount, functionType) {
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('width', '100%');
                    svg.setAttribute('height', (qubitCount + 1) * 40 + 20);
                    svg.setAttribute('viewBox', `0 0 500 ${(qubitCount + 1) * 40 + 20}`);
                    
                    // Draw qubit wires
                    for (let i = 0; i < qubitCount + 1; i++) {
                        const y = 30 + i * 40;
                        
                        // Label
                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('x', '10');
                        text.setAttribute('y', y + 5);
                        text.setAttribute('font-size', '14');
                        text.textContent = i < qubitCount ? `q${i}:` : 'a:';
                        svg.appendChild(text);
                        
                        // Wire
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', '40');
                        line.setAttribute('y1', y);
                        line.setAttribute('x2', '460');
                        line.setAttribute('y2', y);
                        line.setAttribute('stroke', '#333');
                        line.setAttribute('stroke-width', '1');
                        svg.appendChild(line);
                        
                        // Initial state for ancilla qubit
                        if (i === qubitCount) {
                            const initX = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                            initX.setAttribute('x', '50');
                            initX.setAttribute('y', y - 15);
                            initX.setAttribute('width', '30');
                            initX.setAttribute('height', '30');
                            initX.setAttribute('fill', '#f44336');
                            initX.setAttribute('rx', '4');
                            svg.appendChild(initX);
                            
                            const initXLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            initXLabel.setAttribute('x', '65');
                            initXLabel.setAttribute('y', y + 5);
                            initXLabel.setAttribute('font-size', '12');
                            initXLabel.setAttribute('fill', 'white');
                            initXLabel.setAttribute('text-anchor', 'middle');
                            initXLabel.textContent = 'X';
                            svg.appendChild(initXLabel);
                        }
                    }
                    
                    // Draw Hadamard gates
                    for (let i = 0; i < qubitCount + 1; i++) {
                        const y = 30 + i * 40;
                        
                        // Hadamard at the beginning
                        const h1 = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        h1.setAttribute('x', '100');
                        h1.setAttribute('y', y - 15);
                        h1.setAttribute('width', '30');
                        h1.setAttribute('height', '30');
                        h1.setAttribute('fill', '#0066cc');
                        h1.setAttribute('rx', '4');
                        svg.appendChild(h1);
                        
                        const h1Label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        h1Label.setAttribute('x', '115');
                        h1Label.setAttribute('y', y + 5);
                        h1Label.setAttribute('font-size', '12');
                        h1Label.setAttribute('fill', 'white');
                        h1Label.setAttribute('text-anchor', 'middle');
                        h1Label.textContent = 'H';
                        svg.appendChild(h1Label);
                        
                        // Hadamard at the end (except for ancilla)
                        if (i < qubitCount) {
                            const h2 = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                            h2.setAttribute('x', '340');
                            h2.setAttribute('y', y - 15);
                            h2.setAttribute('width', '30');
                            h2.setAttribute('height', '30');
                            h2.setAttribute('fill', '#0066cc');
                            h2.setAttribute('rx', '4');
                            svg.appendChild(h2);
                            
                            const h2Label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            h2Label.setAttribute('x', '355');
                            h2Label.setAttribute('y', y + 5);
                            h2Label.setAttribute('font-size', '12');
                            h2Label.setAttribute('fill', 'white');
                            h2Label.setAttribute('text-anchor', 'middle');
                            h2Label.textContent = 'H';
                            svg.appendChild(h2Label);
                        }
                    }
                    
                    // Draw Oracle
                    const oracleX = 220;
                    const oracleY = 30 + (qubitCount + 1) * 40 / 2;
                    const oracleHeight = (qubitCount + 1) * 40 - 20;
                    
                    const oracle = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    oracle.setAttribute('x', oracleX - 40);
                    oracle.setAttribute('y', 30 - 15);
                    oracle.setAttribute('width', '80');
                    oracle.setAttribute('height', oracleHeight);
                    oracle.setAttribute('fill', '#f0f7ff');
                    oracle.setAttribute('stroke', '#0066cc');
                    oracle.setAttribute('stroke-width', '2');
                    oracle.setAttribute('rx', '4');
                    svg.appendChild(oracle);
                    
                    const oracleLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    oracleLabel.setAttribute('x', oracleX);
                    oracleLabel.setAttribute('y', oracleY);
                    oracleLabel.setAttribute('font-size', '14');
                    oracleLabel.setAttribute('fill', '#0066cc');
                    oracleLabel.setAttribute('text-anchor', 'middle');
                    oracleLabel.textContent = 'Oracol';
                    svg.appendChild(oracleLabel);
                    
                    const oracleFn = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    oracleFn.setAttribute('x', oracleX);
                    oracleFn.setAttribute('y', oracleY + 20);
                    oracleFn.setAttribute('font-size', '12');
                    oracleFn.setAttribute('fill', '#0066cc');
                    oracleFn.setAttribute('text-anchor', 'middle');
                    if (functionType === 'constant-0') {
                        oracleFn.textContent = 'f(x) = 0';
                    } else if (functionType === 'constant-1') {
                        oracleFn.textContent = 'f(x) = 1';
                    } else {
                        oracleFn.textContent = 'f(x) echilibrat';
                    }
                    svg.appendChild(oracleFn);
                    
                    // Draw measurements
                    for (let i = 0; i < qubitCount; i++) {
                        const y = 30 + i * 40;
                        
                        // Measurement symbol
                        const measureRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        measureRect.setAttribute('x', '400');
                        measureRect.setAttribute('y', y - 15);
                        measureRect.setAttribute('width', '30');
                        measureRect.setAttribute('height', '30');
                        measureRect.setAttribute('fill', '#e0e0e0');
                        measureRect.setAttribute('stroke', '#0066cc');
                        measureRect.setAttribute('stroke-width', '2');
                        measureRect.setAttribute('rx', '4');
                        svg.appendChild(measureRect);
                        
                        // Symbol resembling a measurement
                        const measurePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        measurePath.setAttribute('d', `M405,${y-7} L405,${y+3} L409,${y+3} L409,${y-3} L415,${y-3} L415,${y} L419,${y} L419,${y-7} Z`);
                        measurePath.setAttribute('fill', '#0066cc');
                        svg.appendChild(measurePath);
                        
                        const measurePath2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        measurePath2.setAttribute('d', `M415,${y+3} L415,${y+7} L412,${y+7} L415,${y+10} L418,${y+7} L415,${y+7} Z`);
                        measurePath2.setAttribute('fill', '#0066cc');
                        svg.appendChild(measurePath2);
                        
                        // Measurement result
                        if (functionType.startsWith('constant')) {
                            // All 0s for constant functions
                            const resultText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            resultText.setAttribute('x', '445');
                            resultText.setAttribute('y', y + 5);
                            resultText.setAttribute('font-size', '14');
                            resultText.setAttribute('font-weight', 'bold');
                            resultText.setAttribute('fill', '#4CAF50');
                            resultText.textContent = '0';
                            svg.appendChild(resultText);
                        } else {
                            // Mix of 0s and 1s for balanced functions
                            // Simplified: use a pattern based on qubit index
                            const result = (i % 2 === 0) ? '1' : '0';
                            const resultText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            resultText.setAttribute('x', '445');
                            resultText.setAttribute('y', y + 5);
                            resultText.setAttribute('font-size', '14');
                            resultText.setAttribute('font-weight', 'bold');
                            resultText.setAttribute('fill', result === '0' ? '#4CAF50' : '#f44336');
                            resultText.textContent = result;
                            svg.appendChild(resultText);
                        }
                    }
                    
                    return svg;
                }
            }
            
            // Grover's Algorithm Implementation
            function initializeGrover() {
                const databaseSizeSelect = document.getElementById('grover-database-size');
                const targetOptions = document.getElementById('target-options');
                const runButton = document.getElementById('run-grover');
                const nextIterationBtn = document.getElementById('next-iteration');
                const iterationCount = document.getElementById('iteration-count');
                
                let selectedTarget = 3; // Default
                let currentIteration = 0;
                let maxIterations = 0;
                let databaseSize = 4;
                
                // Set up target selection
                updateTargetOptions(4);
                
                databaseSizeSelect.addEventListener('change', function() {
                    databaseSize = parseInt(this.value);
                    updateTargetOptions(databaseSize);
                });
                
                // Handle target selection
                targetOptions.addEventListener('click', function(e) {
                    if (e.target.classList.contains('target-option')) {
                        // Update selected target
                        document.querySelectorAll('.target-option').forEach(btn => {
                            btn.classList.remove('selected');
                        });
                        e.target.classList.add('selected');
                        selectedTarget = parseInt(e.target.getAttribute('data-target'));
                    }
                });
                
                // Run button
                runButton.addEventListener('click', function() {
                    runGroverSearch(databaseSize, selectedTarget);
                });
                
                // Next iteration button
                nextIterationBtn.addEventListener('click', function() {
                    if (currentIteration < maxIterations) {
                        currentIteration++;
                        updateGroverVisualization(databaseSize, selectedTarget, currentIteration, maxIterations);
                    }
                });
                
                function updateTargetOptions(size) {
                    // Clear existing options
                    targetOptions.innerHTML = '';
                    
                    // Add new options
                    for (let i = 0; i < size; i++) {
                        const btn = document.createElement('button');
                        btn.className = 'target-option';
                        if (i === selectedTarget && i < size) {
                            btn.classList.add('selected');
                        } else if (selectedTarget >= size && i === size - 1) {
                            // If previous target is out of new range, select last item
                            btn.classList.add('selected');
                            selectedTarget = i;
                        }
                        btn.setAttribute('data-target', i);
                        btn.textContent = i;
                        targetOptions.appendChild(btn);
                    }
                }
                
                function runGroverSearch(size, target) {
                    // Calculate optimal number of iterations
                    // Approximate formula: π/4 * sqrt(N)
                    const n = Math.log2(size);
                    maxIterations = Math.floor(Math.PI/4 * Math.sqrt(size));
                    if (maxIterations < 1) maxIterations = 1;
                    
                    // Reset state
                    currentIteration = 0;
                    
                    // Update UI
                    iterationCount.textContent = `Iterația: ${currentIteration} / ${maxIterations}`;
                    nextIterationBtn.disabled = false;
                    
                    // Initialize visualization
                    updateGroverVisualization(size, target, 0, maxIterations);
                    
                    // Clear results area
                    document.getElementById('grover-result').innerHTML = '<p class="placeholder-text">Executați toate iterațiile pentru a vedea rezultatul final...</p>';
                }
                
                function updateGroverVisualization(size, target, iteration, maxIterations) {
                    const databaseItems = document.getElementById('database-items');
                    databaseItems.innerHTML = '';
                    
                    // Update iteration counter
                    iterationCount.textContent = `Iterația: ${iteration} / ${maxIterations}`;
                    
                    // Calculate amplitudes based on iteration
                    const amplitudes = calculateGroverAmplitudes(size, target, iteration);
                    
                    // Create visualization
                    for (let i = 0; i < size; i++) {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'database-item';
                        if (i === target) {
                            itemDiv.classList.add('target-item');
                        }
                        
                        const amplitude = amplitudes[i];
                        const probability = Math.pow(amplitude, 2) * 100;
                        
                        // Amplitude bar
                        const barContainer = document.createElement('div');
                        barContainer.className = 'amplitude-container';
                        
                        const bar = document.createElement('div');
                        bar.className = 'amplitude-bar';
                        bar.style.height = `${Math.abs(amplitude) * 100}%`;
                        // Blue for positive amplitudes, red for negative
                        bar.style.backgroundColor = amplitude >= 0 ? '#0066cc' : '#f44336';
                        
                        barContainer.appendChild(bar);
                        
                        // Item number and probability
                        const itemInfo = document.createElement('div');
                        itemInfo.className = 'item-info';
                        
                        const itemNumber = document.createElement('div');
                        itemNumber.className = 'item-number';
                        itemNumber.textContent = `|${i.toString(2).padStart(Math.log2(size), '0')}⟩`;
                        
                        const itemProb = document.createElement('div');
                        itemProb.className = 'item-probability';
                        itemProb.textContent = `${probability.toFixed(1)}%`;
                        
                        itemInfo.appendChild(itemNumber);
                        itemInfo.appendChild(itemProb);
                        
                        // Assemble item
                        itemDiv.appendChild(barContainer);
                        itemDiv.appendChild(itemInfo);
                        databaseItems.appendChild(itemDiv);
                    }
                    
                    // If we've reached the last iteration, show the final result
                    if (iteration === maxIterations) {
                        showGroverResult(size, target);
                        nextIterationBtn.disabled = true;
                    }
                }
                
                function calculateGroverAmplitudes(size, target, iteration) {
                    // Start with uniform superposition
                    const amplitudes = Array(size).fill(1 / Math.sqrt(size));
                    
                    // Apply Grover iterations
                    if (iteration > 0) {
                        const mean = 1 / Math.sqrt(size);
                        const theta = Math.asin(mean);
                        const rotationAngle = iteration * 2 * theta;
                        
                        // Calculate new amplitudes after rotation
                        for (let i = 0; i < size; i++) {
                            if (i === target) {
                                // Target amplitude increases with each iteration
                                amplitudes[i] = Math.sin((2 * iteration + 1) * theta);
                            } else {
                                // Non-target amplitudes decrease
                                amplitudes[i] = Math.cos((2 * iteration + 1) * theta) / Math.sqrt(size - 1);
                            }
                        }
                    }
                    
                    return amplitudes;
                }
                
                function showGroverResult(size, target) {
                    // Calculate final amplitudes
                    const amplitudes = calculateGroverAmplitudes(size, target, maxIterations);
                    
                    // Find highest probability state
                    let maxProbIndex = 0;
                    let maxProb = 0;
                    for (let i = 0; i < amplitudes.length; i++) {
                        const prob = Math.pow(amplitudes[i], 2);
                        if (prob > maxProb) {
                            maxProb = prob;
                            maxProbIndex = i;
                        }
                    }
                    
                    // Check if found the right element
                    const success = maxProbIndex === target;
                    
                    const resultHtml = `
                        <div class="algorithm-result-box ${success ? 'success' : 'error'}">
                            <h5>${success ? 'Căutare Reușită!' : 'Căutare Nereușită'}</h5>
                            <p>${success ? 
                                `Elementul căutat <strong>|${target.toString(2).padStart(Math.log2(size), '0')}⟩</strong> a fost găsit cu probabilitate ${(maxProb * 100).toFixed(1)}%.` : 
                                `Algoritmul a returnat <strong>|${maxProbIndex.toString(2).padStart(Math.log2(size), '0')}⟩</strong> în loc de <strong>|${target.toString(2).padStart(Math.log2(size), '0')}⟩</strong>.`
                            }</p>
                            <div class="result-details">
                                <p>Dimensiune bază de date: ${size} elemente</p>
                                <p>Număr de iterații Grover: ${maxIterations}</p>
                                <p>Complexitate cuantică: O(√${size}) = O(${Math.sqrt(size).toFixed(2)})</p>
                                <p>Complexitate clasică: O(${size})</p>
                            </div>
                        </div>
                    `;
                    
                    document.getElementById('grover-result').innerHTML = resultHtml;
                }
            }
            
            // Shor's Algorithm Implementation
            function initializeShor() {
                const numberSelect = document.getElementById('number-to-factorize');
                const runButton = document.getElementById('run-shor');
                
                runButton.addEventListener('click', function() {
                    const number = parseInt(numberSelect.value);
                    runShorFactorization(number);
                });
                
                function runShorFactorization(number) {
                    // Display loading indicators
                    document.getElementById('shor-step1').innerHTML = 
                        '<div class="loading-animation"><div class="quantum-loading"></div><p>Procesare...</p></div>';
                    document.getElementById('shor-step2').innerHTML = 
                        '<div class="loading-animation"><div class="quantum-loading"></div><p>Procesare...</p></div>';
                    document.getElementById('shor-step3').innerHTML = 
                        '<div class="loading-animation"><div class="quantum-loading"></div><p>Procesare...</p></div>';
                    document.getElementById('shor-result').innerHTML = 
                        '<div class="loading-animation"><div class="quantum-loading"></div><p>Calculare factori...</p></div>';
                    
                    // Simulate delay for processing steps
                    setTimeout(() => {
                        // Step 1: Select random number and check GCD
                        const a = selectRandomNumberForShor(number);
                        const gcd = calculateGCD(a, number);
                        
                        let step1Html;
                        if (gcd !== 1) {
                            // Lucky! Found a factor directly
                            step1Html = `
                                <div class="shor-computation">
                                    <p>1. Am ales numărul aleatoriu a = ${a}</p>
                                    <p>2. Am calculat GCD(a, N) = GCD(${a}, ${number}) = ${gcd}</p>
                                    <p>3. GCD ≠ 1, am găsit un factor direct: ${gcd}</p>
                                </div>
                            `;
                            
                            document.getElementById('shor-step1').innerHTML = step1Html;
                            document.getElementById('shor-step2').innerHTML = '<p>Pas omis - nu este necesar deoarece am găsit un factor direct.</p>';
                            document.getElementById('shor-step3').innerHTML = '<p>Pas omis - nu este necesar deoarece am găsit un factor direct.</p>';
                            
                            const resultHtml = `
                                <div class="algorithm-result-box success">
                                    <h5>Factorizare Reușită!</h5>
                                    <p>${number} = ${gcd} × ${number/gcd}</p>
                                    <div class="result-details">
                                        <p>Factori primi: ${isPrime(gcd) ? gcd : 'Necesită factorizare ulterioară'} și ${isPrime(number/gcd) ? number/gcd : 'Necesită factorizare ulterioară'}</p>
                                        <p>Metodă: calcul direct GCD</p>
                                    </div>
                                </div>
                            `;
                            
                            document.getElementById('shor-result').innerHTML = resultHtml;
                        } else {
                            // Need to find the period using quantum phase estimation
                            step1Html = `
                                <div class="shor-computation">
                                    <p>1. Am ales numărul aleatoriu a = ${a}</p>
                                    <p>2. Am calculat GCD(a, N) = GCD(${a}, ${number}) = ${gcd}</p>
                                    <p>3. GCD = 1, trebuie să găsim perioada funcției f(x) = ${a}<sup>x</sup> mod ${number}</p>
                                </div>
                                <div class="function-values">
                                    <table class="function-table">
                                        <tr>
                                            <th>x</th>
                                            <th>f(x) = ${a}<sup>x</sup> mod ${number}</th>
                                        </tr>
                            `;
                            
                            // Calculate function values to display pattern
                            const functionValues = [];
                            for (let x = 0; x <= 10; x++) {
                                const fx = modPow(a, x, number);
                                functionValues.push({ x, fx });
                                step1Html += `<tr><td>${x}</td><td>${fx}</td></tr>`;
                            }
                            
                            step1Html += `
                                    </table>
                                </div>
                            `;
                            
                            document.getElementById('shor-step1').innerHTML = step1Html;
                            
                            // Step 2: Find period using QFT (simulated)
                            setTimeout(() => {
                                const period = findPeriodForShor(a, number);
                                
                                const step2Html = `
                                    <div class="shor-computation">
                                        <p>1. Executăm Estimarea Fazei Cuantice pentru a găsi perioada r</p>
                                        <p>2. Aplicăm QFT pe starea pregătită</p>
                                        <p>3. Măsurăm și obținem perioada r = ${period}</p>
                                    </div>
                                    <div class="qft-illustration">
                                        <div class="qft-circuit-simple">
                                            <svg width="300" height="150" viewBox="0 0 300 150">
                                                <!-- Register 1 -->
                                                <text x="10" y="30" font-size="12">|0⟩</text>
                                                <line x1="30" y1="30" x2="270" y2="30" stroke="#333" stroke-width="1"/>
                                                <rect x="50" y="15" width="30" height="30" fill="#0066cc" rx="4"/>
                                                <text x="65" y="35" font-size="12" fill="white" text-anchor="middle">H</text>
                                                <rect x="150" y="15" width="30" height="30" fill="#0066cc" rx="4"/>
                                                <text x="165" y="35" font-size="12" fill="white" text-anchor="middle">QFT</text>
                                                <rect x="230" y="15" width="30" height="30" fill="#e0e0e0" stroke="#0066cc" stroke-width="2" rx="4"/>
                                                <path d="M235,23 L235,33 L239,33 L239,27 L245,27 L245,30 L249,30 L249,23 Z M245,33 L245,37 L242,37 L245,40 L248,37 L245,37 Z" fill="#0066cc"/>

                                                <!-- Register 2 -->
                                                <text x="10" y="80" font-size="12">|0⟩</text>
                                                <line x1="30" y1="80" x2="270" y2="80" stroke="#333" stroke-width="1"/>
                                                <rect x="100" y="65" width="30" height="30" fill="#f0f7ff" stroke="#0066cc" stroke-width="2" rx="4"/>
                                                <text x="115" y="85" font-size="12" fill="#0066cc" text-anchor="middle">U<tspan dy="-5" font-size="8">a</tspan></text>
                                                
                                                <!-- Control lines -->
                                                <line x1="115" y1="45" x2="115" y2="65" stroke="#0066cc" stroke-width="2" stroke-dasharray="3,3"/>
                                            </svg>
                                        </div>
                                        <p class="qft-caption">Circuit simplificat pentru Estimarea Fazei folosind QFT</p>
                                    </div>
                                `;
                                
                                document.getElementById('shor-step2').innerHTML = step2Html;
                                
                                // Step 3: Calculate factors
                                setTimeout(() => {
                                    let step3Html;
                                    let resultHtml;
                                    
                                    // Check if period is valid
                                    if (period % 2 === 0) {
                                        const halfPower = modPow(a, period / 2, number);
                                        const factor1 = calculateGCD(halfPower - 1, number);
                                        const factor2 = calculateGCD(halfPower + 1, number);
                                        
                                        if (factor1 > 1 && factor1 < number) {
                                            // Found a factor!
                                            step3Html = `
                                                <div class="shor-computation">
                                                    <p>1. Perioada r = ${period} este pară</p>
                                                    <p>2. Calculăm ${a}<sup>${period/2}</sup> mod ${number} = ${halfPower}</p>
                                                    <p>3. Calculăm GCD(${halfPower} - 1, ${number}) = ${factor1}</p>
                                                    <p>4. Factorul găsit: ${factor1}</p>
                                                </div>
                                            `;
                                            
                                            resultHtml = `
                                                <div class="algorithm-result-box success">
                                                    <h5>Factorizare Reușită!</h5>
                                                    <p>${number} = ${factor1} × ${number/factor1}</p>
                                                    <div class="result-details">
                                                        <p>Factori primi: ${isPrime(factor1) ? factor1 : 'Necesită factorizare ulterioară'} și ${isPrime(number/factor1) ? number/factor1 : 'Necesită factorizare ulterioară'}</p>
                                                        <p>Metodă: Algoritmul lui Shor</p>
                                                    </div>
                                                </div>
                                            `;
                                        } else if (factor2 > 1 && factor2 < number) {
                                            // Found a factor using the other formula
                                            step3Html = `
                                                <div class="shor-computation">
                                                    <p>1. Perioada r = ${period} este pară</p>
                                                    <p>2. Calculăm ${a}<sup>${period/2}</sup> mod ${number} = ${halfPower}</p>
                                                    <p>3. Calculăm GCD(${halfPower} + 1, ${number}) = ${factor2}</p>
                                                    <p>4. Factorul găsit: ${factor2}</p>
                                                </div>
                                            `;
                                            
                                            resultHtml = `
                                                <div class="algorithm-result-box success">
                                                    <h5>Factorizare Reușită!</h5>
                                                    <p>${number} = ${factor2} × ${number/factor2}</p>
                                                    <div class="result-details">
                                                        <p>Factori primi: ${isPrime(factor2) ? factor2 : 'Necesită factorizare ulterioară'} și ${isPrime(number/factor2) ? number/factor2 : 'Necesită factorizare ulterioară'}</p>
                                                        <p>Metodă: Algoritmul lui Shor</p>
                                                    </div>
                                                </div>
                                            `;
                                        } else {
                                            // Failed to find a factor
                                            step3Html = `
                                                <div class="shor-computation">
                                                    <p>1. Perioada r = ${period} este pară</p>
                                                    <p>2. Calculăm ${a}<sup>${period/2}</sup> mod ${number} = ${halfPower}</p>
                                                    <p>3. Calculăm GCD(${halfPower} - 1, ${number}) = ${factor1}</p>
                                                    <p>4. Calculăm GCD(${halfPower} + 1, ${number}) = ${factor2}</p>
                                                    <p>5. Nu am găsit factori netriviali</p>
                                                </div>
                                            `;
                                            
                                            resultHtml = `
                                                <div class="algorithm-result-box warning">
                                                    <h5>Încercați din nou</h5>
                                                    <p>Algoritmul lui Shor nu a găsit factori netriviali pentru ${number} în această rulare.</p>
                                                    <div class="result-details">
                                                        <p>Cauză posibilă: am nimerit un 'a' sau o perioadă care nu conduce la factori.</p>
                                                        <p>Soluție: Algoritmul lui Shor este probabilistic. Rulați-l din nou cu alt număr aleatoriu a.</p>
                                                    </div>
                                                </div>
                                            `;
                                        }
                                    } else {
                                        // Odd period can't be used to factor
                                        step3Html = `
                                            <div class="shor-computation">
                                                <p>1. Perioada r = ${period} este impară</p>
                                                <p>2. Nu putem folosi această perioadă pentru factorizare</p>
                                                <p>3. Este necesară o nouă rulare a algoritmului</p>
                                            </div>
                                        `;
                                        
                                        resultHtml = `
                                            <div class="algorithm-result-box warning">
                                                <h5>Încercați din nou</h5>
                                                <p>Algoritmul lui Shor a găsit o perioadă impară (r = ${period}) care nu poate fi folosită pentru factorizare.</p>
                                                <div class="result-details">
                                                    <p>Cauză: Algoritmul funcționează când perioada este pară.</p>
                                                    <p>Soluție: Algoritmul lui Shor este probabilistic. Rulați-l din nou cu alt număr aleatoriu a.</p>
                                                </div>
                                            </div>
                                        `;
                                    }
                                    
                                    document.getElementById('shor-step3').innerHTML = step3Html;
                                    document.getElementById('shor-result').innerHTML = resultHtml;
                                }, 1000);
                            }, 1000);
                        }
                    }, 1500);
                }
                
                function selectRandomNumberForShor(n) {
                    // Determine factors of the number to select a realistic 'a'
                    // For demonstration, we'll pick values that work well
                    const predefinedValues = {
                        15: 7,  // period = 4
                        21: 2,  // period = 6
                        35: 4   // period = 6
                    };
                    
                    return predefinedValues[n] || Math.floor(Math.random() * (n - 2)) + 2;
                }
                
                function findPeriodForShor(a, n) {
                    // Hardcoded periods for demonstration
                    const knownPeriods = {
                        '7,15': 4,
                        '2,21': 6,
                        '4,35': 6
                    };
                    
                    return knownPeriods[`${a},${n}`] || 4;  // Default to 4 for demo
                }
                
                function calculateGCD(a, b) {
                    while (b) {
                        const temp = b;
                        b = a % b;
                        a = temp;
                    }
                    return a;
                }
                
                function modPow(base, exponent, modulus) {
                    if (modulus === 1) return 0;
                    
                    let result = 1;
                    base = base % modulus;
                    
                    while (exponent > 0) {
                        if (exponent % 2 === 1) {
                            result = (result * base) % modulus;
                        }
                        exponent = Math.floor(exponent / 2);
                        base = (base * base) % modulus;
                    }
                    
                    return result;
                }
                
                function isPrime(num) {
                    if (num <= 1) return false;
                    if (num <= 3) return true;
                    if (num % 2 === 0 || num % 3 === 0) return false;
                    
                    let i = 5;
                    while (i * i <= num) {
                        if (num % i === 0 || num % (i + 2) === 0) return false;
                        i += 6;
                    }
                    
                    return true;
                }
            }
            
            // QFT Implementation
            function initializeQFT() {
                const inputStateSelect = document.getElementById('qft-input-state');
                const qubitCountSelect = document.getElementById('qft-qubit-count');
                const customStateConfig = document.getElementById('custom-state-config');
                const runButton = document.getElementById('run-qft');
                
                // Show/hide custom state configuration
                inputStateSelect.addEventListener('change', function() {
                    if (this.value === 'custom') {
                        customStateConfig.style.display = 'block';
                        updateCustomStateInputs();
                    } else {
                        customStateConfig.style.display = 'none';
                    }
                });
                
                // Update custom state inputs when qubit count changes
                qubitCountSelect.addEventListener('change', function() {
                    if (inputStateSelect.value === 'custom') {
                        updateCustomStateInputs();
                    }
                });
                
                // Run QFT
                runButton.addEventListener('click', function() {
                    const stateType = inputStateSelect.value;
                    const qubitCount = parseInt(qubitCountSelect.value);
                    
                    let initialState;
                    if (stateType === 'custom') {
                        initialState = getCustomState(qubitCount);
                    } else {
                        initialState = generateState(stateType, qubitCount);
                    }
                    
                    runQFT(initialState, qubitCount);
                });
                
                function updateCustomStateInputs() {
                    const container = document.querySelector('.custom-amplitudes');
                    container.innerHTML = '';
                    
                    const qubitCount = parseInt(qubitCountSelect.value);
                    const stateCount = Math.pow(2, qubitCount);
                    
                    // Add amplitude inputs for each basis state
                    for (let i = 0; i < stateCount; i++) {
                        const stateLabel = i.toString(2).padStart(qubitCount, '0');
                        
                        const inputGroup = document.createElement('div');
                        inputGroup.className = 'custom-amplitude';
                        
                        const label = document.createElement('label');
                        label.textContent = `|${stateLabel}⟩:`;
                        
                        const input = document.createElement('input');
                        input.type = 'number';
                        input.step = '0.1';
                        input.min = '0';
                        input.max = '1';
                        input.value = i === 0 ? '1' : '0';  // Default to |0...0⟩
                        input.className = 'amplitude-input';
                        input.dataset.state = i;
                        
                        inputGroup.appendChild(label);
                        inputGroup.appendChild(input);
                        container.appendChild(inputGroup);
                    }
                }
                
                function getCustomState(qubitCount) {
                    const stateCount = Math.pow(2, qubitCount);
                    const amplitudes = Array(stateCount).fill(0);
                    let sum = 0;
                    
                    // Get values from inputs
                    const inputs = document.querySelectorAll('.amplitude-input');
                    inputs.forEach(input => {
                        const stateIndex = parseInt(input.dataset.state);
                        const value = parseFloat(input.value) || 0;
                        amplitudes[stateIndex] = value;
                        sum += value * value;
                    });
                    
                    // Normalize if needed
                    if (sum > 0 && Math.abs(sum - 1) > 0.001) {
                        const scaleFactor = 1 / Math.sqrt(sum);
                        for (let i = 0; i < amplitudes.length; i++) {
                            amplitudes[i] *= scaleFactor;
                        }
                    }
                    
                    return amplitudes;
                }
                
                function generateState(type, qubitCount) {
                    const stateCount = Math.pow(2, qubitCount);
                    const state = Array(stateCount).fill(0);
                    
                    switch (type) {
                        case 'basis':
                            // |0...0⟩ state
                            state[0] = 1;
                            break;
                            
                        case 'uniform':
                            // Uniform superposition
                            const amplitude = 1 / Math.sqrt(stateCount);
                            for (let i = 0; i < stateCount; i++) {
                                state[i] = amplitude;
                            }
                            break;
                            
                        case 'periodic':
                            // A periodic state (for demo purposes)
                            const period = Math.floor(stateCount / 4) || 1;
                            const normFactor = 1 / Math.sqrt(Math.ceil(stateCount / period));
                            
                            for (let i = 0; i < stateCount; i += period) {
                                state[i] = normFactor;
                            }
                            break;
                    }
                    
                    return state;
                }
                
                function runQFT(initialState, qubitCount) {
                    // Show loading states
                    document.getElementById('initial-state').innerHTML = 
                        '<div class="loading-animation"><div class="quantum-loading"></div><p>Calculare stare inițială...</p></div>';
                    document.getElementById('qft-state').innerHTML = 
                        '<div class="loading-animation"><div class="quantum-loading"></div><p>Aplicare QFT...</p></div>';
                    document.getElementById('qft-circuit').innerHTML = 
                        '<div class="loading-animation"><div class="quantum-loading"></div><p>Generare circuit...</p></div>';
                    
                    // Simulate delay for calculation
                    setTimeout(() => {
                        // Apply QFT (simulated)
                        const qftState = simulateQFT(initialState);
                        
                        // Update visualizations
                        updateStateVisualization('initial-state', initialState, qubitCount);
                        updateStateVisualization('qft-state', qftState, qubitCount);
                        generateQFTCircuit(qubitCount);
                    }, 1500);
                }
                
                function simulateQFT(state) {
                    // Simple simulation of QFT output
                    // In reality, this would be a proper matrix multiplication
                    
                    const n = Math.log2(state.length);
                    const result = Array(state.length).fill(0).map(() => ({ real: 0, imag: 0 }));
                    
                    // Apply QFT formula
                    for (let k = 0; k < state.length; k++) {
                        for (let j = 0; j < state.length; j++) {
                            // e^(2πi*j*k/2^n) coefficient
                            const angle = 2 * Math.PI * j * k / state.length;
                            const real = Math.cos(angle) * state[j];
                            const imag = Math.sin(angle) * state[j];
                            
                            result[k].real += real / Math.sqrt(state.length);
                            result[k].imag += imag / Math.sqrt(state.length);
                        }
                    }
                    
                    // Convert to amplitudes (magnitudes)
                    return result.map(c => Math.sqrt(c.real * c.real + c.imag * c.imag));
                }
                
                function updateStateVisualization(containerId, state, qubitCount) {
                    const container = document.getElementById(containerId);
                    container.innerHTML = '';
                    
                    // Create state visualization
                    const stateDiv = document.createElement('div');
                    stateDiv.className = 'amplitudes-visual';
                    
                    for (let i = 0; i < state.length; i++) {
                        const amplitude = state[i];
                        const stateLabel = i.toString(2).padStart(qubitCount, '0');
                        
                        const amplitudeBar = document.createElement('div');
                        amplitudeBar.className = 'amplitude-item';
                        
                        const label = document.createElement('div');
                        label.className = 'amplitude-label';
                        label.textContent = `|${stateLabel}⟩`;
                        
                        const barContainer = document.createElement('div');
                        barContainer.className = 'amplitude-bar-container';
                        
                        const bar = document.createElement('div');
                        bar.className = 'amplitude-bar';
                        bar.style.width = `${amplitude * 100}%`;
                        bar.style.backgroundColor = '#0066cc';
                        
                        const value = document.createElement('div');
                        value.className = 'amplitude-value';
                        value.textContent = amplitude.toFixed(2);
                        
                        barContainer.appendChild(bar);
                        
                        amplitudeBar.appendChild(label);
                        amplitudeBar.appendChild(barContainer);
                        amplitudeBar.appendChild(value);
                        stateDiv.appendChild(amplitudeBar);
                    }
                    
                    container.appendChild(stateDiv);
                }
                
                function generateQFTCircuit(qubitCount) {
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('width', '100%');
                    svg.setAttribute('height', qubitCount * 40 + 20);
                    svg.setAttribute('viewBox', `0 0 500 ${qubitCount * 40 + 20}`);
                    
                    // Draw qubit wires
                    for (let i = 0; i < qubitCount; i++) {
                        const y = 30 + i * 40;
                        
                        // Label
                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('x', '10');
                        text.setAttribute('y', y + 5);
                        text.setAttribute('font-size', '14');
                        text.textContent = `q${i}:`;
                        svg.appendChild(text);
                        
                        // Wire
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', '40');
                        line.setAttribute('y1', y);
                        line.setAttribute('x2', '460');
                        line.setAttribute('y2', y);
                        line.setAttribute('stroke', '#333');
                        line.setAttribute('stroke-width', '1');
                        svg.appendChild(line);
                    }
                    
                    // Draw Hadamard gates (first stage of QFT)
                    for (let i = 0; i < qubitCount; i++) {
                        const y = 30 + i * 40;
                        const x = 80 + i * 20;  // Offset each H gate for better visibility
                        
                        const h = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        h.setAttribute('x', x);
                        h.setAttribute('y', y - 15);
                        h.setAttribute('width', '30');
                        h.setAttribute('height', '30');
                        h.setAttribute('fill', '#0066cc');
                        h.setAttribute('rx', '4');
                        svg.appendChild(h);
                        
                        const hLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        hLabel.setAttribute('x', x + 15);
                        hLabel.setAttribute('y', y + 5);
                        hLabel.setAttribute('font-size', '12');
                        hLabel.setAttribute('fill', 'white');
                        hLabel.setAttribute('text-anchor', 'middle');
                        hLabel.textContent = 'H';
                        svg.appendChild(hLabel);
                    }
                    
                    // Draw controlled rotation gates (second stage of QFT)
                    for (let i = 0; i < qubitCount; i++) {
                        for (let j = i + 1; j < qubitCount; j++) {
                            const controlY = 30 + i * 40;
                            const targetY = 30 + j * 40;
                            const x = 200 + (i * 30) + (j * 10);  // Position gates with some offset
                            
                            // Control point
                            const control = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            control.setAttribute('cx', x);
                            control.setAttribute('cy', controlY);
                            control.setAttribute('r', '5');
                            control.setAttribute('fill', '#0066cc');
                            svg.appendChild(control);
                            
                            // Connection line
                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            line.setAttribute('x1', x);
                            line.setAttribute('y1', controlY);
                            line.setAttribute('x2', x);
                            line.setAttribute('y2', targetY);
                            line.setAttribute('stroke', '#0066cc');
                            line.setAttribute('stroke-width', '2');
                            svg.appendChild(line);
                            
                            // Rotation gate
                            const rotation = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                            rotation.setAttribute('x', x - 15);
                            rotation.setAttribute('y', targetY - 15);
                            rotation.setAttribute('width', '30');
                            rotation.setAttribute('height', '30');
                            rotation.setAttribute('fill', '#f0f7ff');
                            rotation.setAttribute('stroke', '#0066cc');
                            rotation.setAttribute('stroke-width', '2');
                            rotation.setAttribute('rx', '4');
                            svg.appendChild(rotation);
                            
                            // Rotation label
                            const rLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            rLabel.setAttribute('x', x);
                            rLabel.setAttribute('y', targetY + 5);
                            rLabel.setAttribute('font-size', '10');
                            rLabel.setAttribute('fill', '#0066cc');
                            rLabel.setAttribute('text-anchor', 'middle');
                            rLabel.textContent = `R${j-i+1}`;
                            svg.appendChild(rLabel);
                        }
                    }
                    
                    // Draw swap network (third stage of QFT)
                    for (let i = 0; i < Math.floor(qubitCount / 2); i++) {
                        const topY = 30 + i * 40;
                        const bottomY = 30 + (qubitCount - i - 1) * 40;
                        const x = 380;
                        
                        // Swap symbol (X)
                        const swap1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        swap1.setAttribute('x1', x - 10);
                        swap1.setAttribute('y1', topY - 10);
                        swap1.setAttribute('x2', x + 10);
                        swap1.setAttribute('y2', topY + 10);
                        swap1.setAttribute('stroke', '#0066cc');
                        swap1.setAttribute('stroke-width', '2');
                        svg.appendChild(swap1);
                        
                        const swap2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        swap2.setAttribute('x1', x - 10);
                        swap2.setAttribute('y1', topY + 10);
                        swap2.setAttribute('x2', x + 10);
                        swap2.setAttribute('y2', topY - 10);
                        swap2.setAttribute('stroke', '#0066cc');
                        swap2.setAttribute('stroke-width', '2');
                        svg.appendChild(swap2);
                        
                        // Bottom X
                        const swap3 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        swap3.setAttribute('x1', x - 10);
                        swap3.setAttribute('y1', bottomY - 10);
                        swap3.setAttribute('x2', x + 10);
                        swap3.setAttribute('y2', bottomY + 10);
                        swap3.setAttribute('stroke', '#0066cc');
                        swap3.setAttribute('stroke-width', '2');
                        svg.appendChild(swap3);
                        
                        const swap4 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        swap4.setAttribute('x1', x - 10);
                        swap4.setAttribute('y1', bottomY + 10);
                        swap4.setAttribute('x2', x + 10);
                        swap4.setAttribute('y2', bottomY - 10);
                        swap4.setAttribute('stroke', '#0066cc');
                        swap4.setAttribute('stroke-width', '2');
                        svg.appendChild(swap4);
                        
                        // Connection line
                        const conn = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        conn.setAttribute('x1', x);
                        conn.setAttribute('y1', topY);
                        conn.setAttribute('x2', x);
                        conn.setAttribute('y2', bottomY);
                        conn.setAttribute('stroke', '#0066cc');
                        conn.setAttribute('stroke-width', '2');
                        conn.setAttribute('stroke-dasharray', '4,4');
                        svg.appendChild(conn);
                    }
                    
                    document.getElementById('qft-circuit').innerHTML = '';
                    document.getElementById('qft-circuit').appendChild(svg);
                }
            }
        });
    </script>
    
    <style>
        /* Quantum Algorithms page specific styles */
        .algorithms-intro {
            margin-bottom: 2rem;
        }
        
        .advantage-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            grid-gap: 2rem;
            margin-top: 2rem;
        }
        
        .advantage-card {
            background-color: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
        }
        
        .advantage-card h4 {
            color: #0066cc;
            margin-top: 0;
            margin-bottom: 1rem;
        }
        
        .complexity-comparison {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 1.5rem;
            padding: 1rem;
            background-color: #f8f9fa;
            border-radius: 8px;
        }
        
        .complexity {
            text-align: center;
        }
        
        .complexity-label {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            color: #666;
        }
        
        .complexity-value {
            font-family: 'Courier New', monospace;
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        .complexity-vs {
            margin: 0 1.5rem;
            font-size: 1.2rem;
            font-weight: bold;
            color: #666;
        }
        
        .parallelism-visual {
            margin-top: 1.5rem;
            padding: 1rem;
            background-color: #f8f9fa;
            border-radius: 8px;
        }
        
        .classical-computation,
        .quantum-computation {
            margin-bottom: 1rem;
        }
        
        .computation-label {
            margin-bottom: 0.5rem;
            font-weight: bold;
        }
        
        .computation-path,
        .computation-paths {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-left: 1rem;
        }
        
        .computation-paths {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
        }
        
        .path-step {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: #0066cc;
        }
        
        /* Algorithm Tabs */
        .algorithm-showcase {
            margin-top: 3rem;
        }
        
        .algorithm-tabs {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 2rem;
            overflow-x: auto;
            white-space: nowrap;
        }
        
        .algorithm-tab {
            padding: 1rem 2rem;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            font-size: 1.1rem;
            font-weight: 500;
            color: #666;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .algorithm-tab:hover {
            color: #0066cc;
        }
        
        .algorithm-tab.active {
            color: #0066cc;
            border-bottom-color: #0066cc;
        }
        
        .algorithm-details {
            display: none;
            animation: fadeIn 0.5s ease;
        }
        
        .algorithm-details.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .algorithm-description {
            margin-bottom: 2rem;
        }
        
        .algorithm-interactive {
            background-color: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            margin-bottom: 2rem;
        }
        
        .algorithm-explanation {
            background-color: #f0f7ff;
            padding: 1.5rem;
            border-radius: 8px;
            border-left: 4px solid #0066cc;
        }
        
        .algorithm-explanation h4 {
            color: #0066cc;
            margin-top: 0;
        }
        
        /* Deutsch-Jozsa Interactive */
        .interactive-deutsch {
            display: grid;
            grid-template-columns: 1fr 2fr;
            grid-gap: 2rem;
        }
        
        .deutsch-controls {
            padding-right: 1rem;
            border-right: 1px solid #eee;
        }
        
        .function-selection {
            margin: 1.5rem 0;
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }
        
        .function-selection label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }
        
        .deutsch-qubits {
            margin-bottom: 1.5rem;
        }
        
        .deutsch-qubits select {
            padding: 0.5rem;
            border-radius: 4px;
            border: 1px solid #ccc;
            margin-left: 0.5rem;
        }
        
        .algorithm-visualization {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        
        .circuit-diagram {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
            min-height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .algorithm-results {
            margin-top: auto;
        }
        
        .result-display {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
            min-height: 100px;
        }
        
        .algorithm-result-box {
            padding: 1rem;
            border-radius: 6px;
            border-left: 4px solid;
        }
        
        .algorithm-result-box.success {
            background-color: #e8f5e9;
            border-color: #4CAF50;
        }
        
        .algorithm-result-box.warning {
            background-color: #fff8e1;
            border-color: #FFC107;
        }
        
        .algorithm-result-box.error {
            background-color: #ffebee;
            border-color: #f44336;
        }
        
        .algorithm-result-box h5 {
            margin-top: 0;
            color: #333;
        }
        
        .result-details {
            margin-top: 1rem;
            padding-top: 0.5rem;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            font-size: 0.9rem;
        }
        
        .run-algorithm {
            background-color: #0066cc;
            color: white;
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            font-weight: 500;
            width: 100%;
        }
        
        .run-algorithm:hover {
            background-color: #0055aa;
        }
        
        /* Grover's Algorithm Interactive */
        .interactive-grover {
            display: grid;
            grid-template-columns: 1fr 2fr;
            grid-gap: 2rem;
        }
        
        .grover-controls {
            padding-right: 1rem;
            border-right: 1px solid #eee;
        }
        
        .target-selection {
            margin: 1.5rem 0;
        }
        
        .target-options {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .target-option {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f0f0f0;
            border: 2px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .target-option:hover {
            border-color: #0066cc;
        }
        
        .target-option.selected {
            background-color: #0066cc;
            color: white;
            border-color: #0066cc;
        }
        
        .grover-animation {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        
        .database-visualization {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
        }
        
        .database-items {
            display: flex;
            align-items: flex-end;
            gap: 0.5rem;
            height: 200px;
            padding: 1rem 0;
        }
        
        .database-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
        }
        
        .database-item.target-item {
            border-bottom: 3px solid #ff9800;
        }
        
        .amplitude-container {
            height: 160px;
            width: 100%;
            display: flex;
            align-items: flex-end;
            justify-content: center;
        }
        
        .amplitude-bar {
            width: 80%;
            background-color: #0066cc;
            transition: height 0.5s ease;
        }
        
        .item-info {
            text-align: center;
            margin-top: 0.5rem;
            width: 100%;
        }
        
        .item-number {
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .item-probability {
            font-size: 0.8rem;
            color: #666;
        }
        
        .iterations-control {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem;
            background-color: #f0f7ff;
            border-radius: 4px;
        }
        
        .iteration-btn {
            background-color: #0066cc;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        
        .iteration-btn:hover {
            background-color: #0055aa;
        }
        
        .iteration-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        /* Shor's Algorithm Interactive */
        .interactive-shor {
            display: grid;
            grid-template-columns: 1fr 2fr;
            grid-gap: 2rem;
        }
        
        .shor-controls {
            padding-right: 1rem;
            border-right: 1px solid #eee;
        }
        
        .number-input {
            margin: 1.5rem 0;
        }
        
        .number-input select {
            width: 100%;
            padding: 0.5rem;
            border-radius: 4px;
            border: 1px solid #ccc;
            margin-top: 0.5rem;
        }
        
        .shor-steps {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .shor-step {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
        }
        
        .shor-step h5 {
            margin-top: 0;
            color: #0066cc;
            margin-bottom: 0.5rem;
        }
        
        .shor-computation {
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
        }
        
        .function-values {
            margin-top: 1rem;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .function-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .function-table th {
            background-color: #e0e0e0;
            padding: 0.5rem;
            text-align: left;
        }
        
        .function-table td {
            padding: 0.3rem 0.5rem;
            border-bottom: 1px solid #eee;
        }
        
        .qft-illustration {
            margin-top: 1rem;
            text-align: center;
        }
        
        .qft-circuit-simple {
            background-color: white;
            border-radius: 4px;
            padding: 0.5rem;
            display: inline-block;
        }
        
        .qft-caption {
            margin-top: 0.5rem;
            font-size: 0.8rem;
            color: #666;
        }
        
        /* QFT Interactive */
        .interactive-qft {
            display: grid;
            grid-template-columns: 1fr 2fr;
            grid-gap: 2rem;
        }
        
        .qft-controls {
            padding-right: 1rem;
            border-right: 1px solid #eee;
        }
        
        .input-selection,
        .qubit-selection {
            margin-bottom: 1.5rem;
        }
        
        .input-selection select,
        .qubit-selection select {
            width: 100%;
            padding: 0.5rem;
            border-radius: 4px;
            border: 1px solid #ccc;
            margin-top: 0.5rem;
        }
        
        .custom-state-config {
            margin-top: 1rem;
            padding: 1rem;
            background-color: #f8f9fa;
            border-radius: 8px;
        }
        
        .custom-amplitudes {
            max-height: 200px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .custom-amplitude {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .custom-amplitude input {
            width: 60px;
            padding: 0.3rem;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        
        .qft-visualization {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .state-visualization {
            flex: 1;
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
        }
        
        .qft-arrow {
            width: 50px;
            flex-shrink: 0;
        }
        
        .state-display {
            margin-top: 1rem;
        }
        
        .amplitudes-visual {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .amplitude-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .amplitude-label {
            width: 80px;
            font-family: 'Courier New', monospace;
            white-space: nowrap;
        }
        
        .amplitude-bar-container {
            flex: 1;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .amplitude-value {
            width: 50px;
            text-align: right;
            font-size: 0.9rem;
            color: #666;
        }
        
        .qft-circuit {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
        }
        
        .qft-circuit h5 {
            margin-top: 0;
            color: #0066cc;
            margin-bottom: 0.5rem;
        }
        
        /* Algorithm Comparison Table */
        .algorithm-comparison {
            margin-top: 3rem;
        }
        
        .comparison-table-container {
            overflow-x: auto;
            margin: 2rem 0;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            background-color: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            overflow: hidden;
        }
        
        .comparison-table th {
            background-color: #0066cc;
            color: white;
            padding: 1rem;
            text-align: left;
        }
        
        .comparison-table td {
            padding: 1rem;
            border-bottom: 1px solid #eee;
        }
        
        .comparison-table tr:last-child td {
            border-bottom: none;
        }
        
        .comparison-table tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        
        .comparison-note {
            font-size: 0.9rem;
            color: #666;
            font-style: italic;
        }
        
        /* Resources */
        .algorithm-resources {
            margin-top: 3rem;
        }
        
        .resources-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            grid-gap: 2rem;
            margin-top: 2rem;
        }
        
        .resource-card {
            background-color: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
        }
        
        .resource-card h4 {
            color: #0066cc;
            margin-top: 0;
            margin-bottom: 1rem;
        }
        
        .resource-list {
            padding-left: 1.5rem;
        }
        
        .resource-list li {
            margin-bottom: 0.8rem;
        }
        
        .resource-list a {
            color: #0066cc;
            text-decoration: none;
        }
        
        .resource-list a:hover {
            text-decoration: underline;
        }
        
        /* Math Formula */
        .math-formula {
            font-family: 'Courier New', monospace;
            padding: 1rem;
            background-color: #f8f9fa;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1rem 0;
            text-align: center;
        }
        
        /* Loading Animation */
        .loading-animation {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100px;
        }
        
        .quantum-loading {
            width: 30px;
            height: 30px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #0066cc;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Placeholder */
        .placeholder-text {
            color: #999;
            font-style: italic;
            text-align: center;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .interactive-deutsch,
            .interactive-grover,
            .interactive-shor,
            .interactive-qft {
                grid-template-columns: 1fr;
            }
            
            .deutsch-controls,
            .grover-controls,
            .shor-controls,
            .qft-controls {
                padding-right: 0;
                padding-bottom: 1rem;
                border-right: none;
                border-bottom: 1px solid #eee;
                margin-bottom: 1rem;
            }
            
            .qft-visualization {
                flex-direction: column;
            }
        }
    </style>
</body>
</html>